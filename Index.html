<!DOCTYPE html>
<html dir="rtl" lang="ar">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Raahim's Arabic</title>
  <style>
    :root { --gap: 10px; --max-width: 900px; --grid-cols: 5; }

    body {
      font-family: 'Comic Sans MS', cursive, sans-serif;
      background: #f5f5f5;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      box-sizing: border-box;
    }

    h1 { 
      color: #2e8b57; 
      margin: 0 0 18px 0; 
      position: sticky;
      top: 0;
      background: #f5f5f5;
      padding: 10px 20px;
      border-radius: 0 0 15px 15px;
      z-index: 1000;
      width: 100%;
      text-align: center;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    }

    .container {
      width: 100%;
      max-width: var(--max-width);
      display: grid;
      grid-template-rows: auto 1fr;
      gap: 18px;
      align-items: start;
      box-sizing: border-box;
    }

    /* Floating mouth circle */
    .mouth {
      position: sticky;
      top: 80px; /* Position below the header */
      z-index: 2000;
      margin: 0 auto 20px auto;
      transition: transform 0.18s ease;
      background: white;
      border-radius: 50%;
      border: 6px solid #FFFF00; /* Thicker  border */
      display: flex;
      align-items: center;
      justify-content: center;
      aspect-ratio: 1/1;
      overflow: hidden;
      box-sizing: border-box;
      box-shadow: 0 4px 15px rgba(0,0,0,0.5);
    }
    .mouth.playing { transform: scale(1.03); }

    .mouth img, .mouth video {
      position: absolute;
      inset: 6%;
      width: 88%;
      height: 88%;
      border-radius: 12px;
      object-fit: contain;
      display: block;
      background: transparent;
    }
    .mouth video { z-index: 2; display: none; }
    .mouth img { z-index: 1; }
    .mouth.playing video { display: block; }

    /* Ring animation overlay */
    .mouth-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(-90deg);
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 3;
      overflow: visible;
      display: block;
    }
    .mouth-overlay svg {
      width: 100%;
      height: 100%;
      display: block;
      overflow: visible;
    }
    .overlay-ring {
      fill: none;
      stroke: #000;
      stroke-linecap: round;
      transition: stroke-dashoffset 0.5s ease-in-out;
    }
    @media (prefers-reduced-motion: reduce) {
      .overlay-ring {
        transition: none !important;
      }
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(var(--grid-cols), 1fr);
      grid-template-rows: repeat(6, 1fr);
      gap: var(--gap);
      width: 100%;
      height: 100%;
      align-content: start;
      z-index: 1;
      margin-top: 20px;
    }

    .letter {
      cursor: pointer;
      transition: transform 0.32s ease, opacity 0.28s ease;
      position: relative;
      z-index: 10;
      box-sizing: border-box;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      border: 3px solid;
      background: white;
      aspect-ratio: 1/1;
      overflow: hidden;
    }

    .letter img {
      width: 60%;
      height: 60%;
      object-fit: contain;
      user-select: none;
      pointer-events: none;
    }

    .letter.active { transform: scale(1.95); z-index: 500; }
    .letter.shrink { transform: scale(0.88); opacity: 0.85; }
    .letter.inactive { filter: grayscale(100%); opacity: 0.6; pointer-events: none; }

    .letter:nth-child(5n+1) { border-color: #FF6B6B; }
    .letter:nth-child(5n+2) { border-color: #4ECDC4; }
    .letter:nth-child(5n+3) { border-color: #45B7D1; }
    .letter:nth-child(5n+4) { border-color: #FFBE0B; }
    .letter:nth-child(5n+5) { border-color: #A5DD9B; }

    @media (max-width: 520px) { 
      :root { --grid-cols: 4; } 
      .mouth {
        top: 70px;
      }
    }
  </style>
</head>
<body>
  <h1>Raahim's Arabic</h1>

  <div class="container">
    <!-- Floating mouth circle -->
    <div class="circle mouth" id="mouth" aria-label="شكل الفم">
      <img id="mouthDefault" src="mouths/default.png" alt="Default mouth">
      <video id="mouthVideo" playsinline muted></video>
      
      <!-- Ring animation overlay -->
      <div class="mouth-overlay" id="mouthOverlay" aria-hidden="true">
        <svg id="mouthOverlaySvg" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid meet">
          <circle id="overlayCircle" class="overlay-ring" cx="0" cy="0" r="0" stroke-width="6"></circle>
        </svg>
      </div>
    </div>

    <div class="grid" id="grid" role="list"></div>
  </div>

  <script>
    /*********************** Configuration ***********************/
    const LETTER_KEYS = [
      "alif","baa","taa","thaa","jeem",
      "haa","khaa","daal","zaal","raa",
      "zaa","seen","sheen","suad","duad",
      "tua","zua","ayn","ghayn","faa",
      "qaaf","kaaf","laam","meem","noon",
      "waw","hhaa","hamza","yaa","yaaa"
    ];
    const MIN_RESET_MS = 300;          
    const META_TIMEOUT_MS = 1500;      
    const AUDIO_FALLBACK_MS = 4500;    
    const OVERALL_SAFE_MS = 12000;     
    const MOUTH_SCALE = 1.5;           

    const grid = document.getElementById('grid');
    const mouth = document.getElementById('mouth');
    const mouthVideo = document.getElementById('mouthVideo');
    const mouthDefault = document.getElementById('mouthDefault');

    // Add overlay elements
    const mouthOverlay = document.getElementById('mouthOverlay');
    const mouthOverlaySvg = document.getElementById('mouthOverlaySvg');
    const overlayCircle = document.getElementById('overlayCircle');

    const state = {
      currentEl: null,
      currentKey: null,
      audio: null,
      audioTimer: null,
      metaTimeout: null,
      overallTimer: null,
      overlayCircumference: null,  // Add overlay state
      overlayActive: false         // Add overlay state
    };

    function buildGrid() {
      grid.innerHTML = '';
      LETTER_KEYS.forEach((k) => {
        const el = document.createElement('div');
        el.className = 'letter circle';
        el.setAttribute('data-key', k);
        el.setAttribute('role', 'listitem');
        el.innerHTML = `<img src="images/${k}.png" alt="${k}">`;

        // Every letter clickable
        el.addEventListener('click', () => onLetterClick(el, k));

        grid.appendChild(el);
      });
    }
    buildGrid();

    function syncMouthSize() {
      const sample = grid.querySelector('.letter');
      if (!sample) return;
      const rect = sample.getBoundingClientRect();
      const size = Math.max(48, Math.round(rect.width * MOUTH_SCALE));
      mouth.style.width = size + 'px';
      mouth.style.height = size + 'px';
      updateOverlayForSize(size);  // Add overlay sizing
    }
    window.addEventListener('load', () => { syncMouthSize(); setTimeout(syncMouthSize, 60); });
    window.addEventListener('resize', syncMouthSize);

    function clearAudioTimer() { if (state.audioTimer) { clearTimeout(state.audioTimer); state.audioTimer = null; } }
    function clearMetaTimeout() { if (state.metaTimeout) { clearTimeout(state.metaTimeout); state.metaTimeout = null; } }
    function clearOverallTimer() { if (state.overallTimer) { clearTimeout(state.overallTimer); state.overallTimer = null; } }

    function unloadVideo() {
      try { mouthVideo.pause(); } catch(e){}
      try { mouthVideo.onended = null; mouthVideo.onerror = null; } catch(e){}
      try { mouthVideo.removeAttribute('src'); mouthVideo.load(); } catch(e){}
      mouth.classList.remove('playing');
      mouthVideo.style.display = 'none';
      try { mouthDefault.style.display = 'block'; } catch(e){}
      clearMetaTimeout();
    }

    function unloadAudio() {
      if (state.audio) {
        try {
          state.audio.onended = null;
          state.audio.onerror = null;
        } catch(e){}
        try { state.audio.pause(); state.audio.currentTime = 0; } catch(e){}
      }
      state.audio = null;
      clearAudioTimer();
    }

    function cancelPlayback(resetUI = true) {
      unloadAudio();
      unloadVideo();
      clearOverallTimer();
      overlayReset();  // Reset overlay

      if (resetUI && state.currentEl) {
        state.currentEl.classList.remove('active');
        state.currentEl = null;
        state.currentKey = null;
      }
      Array.from(grid.children).forEach(child => child.classList.remove('shrink'));
    }

    function immediateResetByAudio() {
      unloadVideo();
      if (state.currentEl) state.currentEl.classList.remove('active');
      state.currentEl = null;
      state.currentKey = null;
      Array.from(grid.children).forEach(child => child.classList.remove('shrink'));
      unloadAudio();
      clearOverallTimer();
      overlayReset();  // Reset overlay
    }

    function onLetterClick(el, key) {
      cancelPlayback(true);

      state.currentEl = el;
      state.currentKey = key;
      el.classList.add('active');
      Array.from(grid.children).forEach(child => {
        if (child !== el) child.classList.add('shrink');
      });

      startAudioAndScheduleReset(key, el);
      startVideoOverlay(key);

      clearOverallTimer();
      state.overallTimer = setTimeout(() => {
        immediateResetByAudio();
      }, OVERALL_SAFE_MS);
    }

    function startAudioAndScheduleReset(key, letterEl) {
      unloadAudio();
      clearAudioTimer();
      clearMetaTimeout();

      let audio;
      try {
        audio = new Audio(`sounds/${key}.mp3`);
        audio.preload = 'metadata';
      } catch (e) {
        state.audio = null;
        state.audioTimer = setTimeout(() => immediateResetByAudio(), AUDIO_FALLBACK_MS);
        return;
      }

      const onMeta = () => {
        try { audio.removeEventListener('loadedmetadata', onMeta); } catch(e){}
        const dur = (isFinite(audio.duration) && audio.duration > 0) ? audio.duration : null;
        scheduleResetFromDuration(dur, audio, letterEl);
      };
      audio.addEventListener('loadedmetadata', onMeta, { once: true });

      state.metaTimeout = setTimeout(() => {
        try { audio.removeEventListener('loadedmetadata', onMeta); } catch(e){}
        const dur = (isFinite(audio.duration) && audio.duration > 0) ? audio.duration : null;
        scheduleResetFromDuration(dur, audio, letterEl);
      }, META_TIMEOUT_MS);

      const p = audio.play();
      if (p && typeof p.then === 'function') {
        p.then(() => {
          overlayStart();  // Start overlay animation when audio starts
        }).catch(() => {
          scheduleResetFromDuration(null, audio, letterEl);
        });
      }
      audio.onended = () => { immediateResetByAudio(); };
      audio.onerror = () => { immediateResetByAudio(); };

      state.audio = audio;
    }

    function scheduleResetFromDuration(durationSec, audioObj, letterEl) {
      clearMetaTimeout();
      clearAudioTimer();

      let ms;
      if (durationSec && isFinite(durationSec) && durationSec > 0) {
        ms = Math.max(MIN_RESET_MS, Math.ceil(durationSec * 1000) + 150);
      } else {
        ms = AUDIO_FALLBACK_MS;
      }

      state.audioTimer = setTimeout(() => {
        try { if (state.audio) { state.audio.pause(); state.audio.currentTime = 0; } } catch(e){}
        immediateResetByAudio();
      }, ms);
    }

    function startVideoOverlay(key) {
      try {
        mouth.classList.add('playing');
        mouthVideo.style.display = 'block';
        mouthVideo.src = `mouths/${key}.webm`;
        mouthVideo.load();

        const v = mouthVideo.play();
        if (v && typeof v.then === 'function') {
          v.catch(() => {});
        }

        mouthVideo.onended = () => { unloadVideo(); };
        mouthVideo.onerror = () => { unloadVideo(); };
      } catch (e) {
        unloadVideo();
      }
    }

    // Overlay animation functions
    function updateOverlayForSize(sizePx) {
      const borderPx = 6; // Match the border width
      mouthOverlaySvg.setAttribute('viewBox', `0 0 ${sizePx} ${sizePx}`);
      mouthOverlaySvg.setAttribute('width', sizePx);
      mouthOverlaySvg.setAttribute('height', sizePx);
      const cx = sizePx / 2;
      const cy = sizePx / 2;
      const r = Math.max(2, (sizePx / 2) - (borderPx * 0.5));
      overlayCircle.setAttribute('cx', cx.toString());
      overlayCircle.setAttribute('cy', cy.toString());
      overlayCircle.setAttribute('r', r.toString());
      overlayCircle.setAttribute('stroke-width', borderPx.toString());
      const circumference = 2 * Math.PI * r;
      overlayCircle.style.strokeDasharray = `${circumference}`;
      overlayCircle.style.strokeDashoffset = `${circumference}`;
      state.overlayCircumference = circumference;
    }

    function overlayStart() {
      if (!state.overlayCircumference) { 
        const size = parseFloat(getComputedStyle(mouth).width) || 100; 
        updateOverlayForSize(size); 
      }
      if (state.overlayActive) return;
      
      const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      const c = state.overlayCircumference || 0;
      
      if (prefersReduced) { 
        overlayCircle.style.strokeDashoffset = '0'; 
        state.overlayActive = true; 
        return; 
      }
      
      overlayCircle.style.strokeDashoffset = `${c}`;
      void overlayCircle.getBoundingClientRect();
      requestAnimationFrame(() => { 
        overlayCircle.style.strokeDashoffset = '0'; 
        state.overlayActive = true; 
      });
    }

    function overlayReset() {
      if (!state.overlayActive && !state.overlayCircumference) return;
      
      const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      const c = state.overlayCircumference || 0;
      
      if (prefersReduced) { 
        overlayCircle.style.strokeDashoffset = `${c}`; 
        state.overlayActive = false; 
        return; 
      }
      
      overlayCircle.style.strokeDashoffset = `${c}`;
      state.overlayActive = false;
    }

    window.addEventListener('pagehide', () => cancelPlayback(true));
    window.addEventListener('beforeunload', () => cancelPlayback(true));

    // Initialize overlay on load
    window.addEventListener('load', () => {
      setTimeout(() => {
        const sizePx = parseFloat(getComputedStyle(mouth).width) || 180;
        updateOverlayForSize(sizePx);
      }, 100);
    });
  </script>
</body>
</html>