<!DOCTYPE html>
<html dir="rtl" lang="ar">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Raahim's Arabic</title>
  <style>
    :root { --gap: 10px; --max-width: 900px; --grid-cols: 5; }

    body {
      font-family: 'Comic Sans MS', cursive, sans-serif;
      background: #f5f5f5;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      box-sizing: border-box;
    }

    h1 {
      color: #2e8b57;
      margin: 0 0 18px 0;
      position: sticky;
      top: 0;
      background: #f5f5f5;
      padding: 10px 20px;
      border-radius: 0 0 15px 15px;
      z-index: 1000;
      width: 100%;
      text-align: center;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    }

    .container {
      width: 100%;
      max-width: var(--max-width);
      display: grid;
      grid-template-rows: auto 1fr;
      gap: 18px;
      align-items: start;
      box-sizing: border-box;
    }

    /* wrapper that moves with scroll (holds progress + mouth) */
    .mouth-wrapper {
      position: sticky;
      top: 80px; /* below header */
      z-index: 2000;
      width: 100%;
      max-width: var(--max-width);
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      pointer-events: none; /* let clicks through except on interactive children */
    }

    /* Floating mouth circle with circular progress */
    .mouth-container {
      position: relative;
      width: 180px;
      height: 180px;
      margin: 0 auto 18px auto;
      pointer-events: auto;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .circular-progress {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      transform: rotate(-60deg); /* Start at top (clean) */
      shape-rendering: geometricPrecision;
    }

    .progress-ring {
      width: 100%;
      height: 100%;
      shape-rendering: geometricPrecision;
    }

    .progress-ring-circle {
      fill: none;
      stroke: transparent;
      stroke-width: 6;
    }

    .progress-ring-value {
      fill: none;
      stroke: #FFD700;
      stroke-width: 6;
      stroke-linecap: round;
      transition: stroke-dashoffset 0.45s cubic-bezier(.2,.9,.2,1);
    }

    .progress-text-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      pointer-events: none;
    }

    .progress-text {
      font-size: 14px;
      color: #333;
      margin: 0;
    }


    /* Curved text that lives in the arc gap */
.gap-text {
  font-size: 8px;
  font-weight: 700;
  fill: #333;
  pointer-events: none; /* don’t steal clicks */
}


    .mouth {
      transition: transform 0.18s ease;
      background: white;
      border-radius: 50%;
      border: 6px solid #FFFF00; /* Thicker border */
      display: flex;
      align-items: center;
      justify-content: center;
      aspect-ratio: 1/1;
      overflow: hidden;
      box-sizing: border-box;
      box-shadow: 0 4px 15px rgba(0,0,0,0.5);
      position: relative;
      width: 140px; /* default will be overridden by JS syncMouthSize */
      height: 140px;
      z-index: 2001;
    }
    .mouth.playing { transform: scale(1.03); }

    .mouth img, .mouth video {
      position: absolute;
      inset: 6%;
      width: 88%;
      height: 88%;
      border-radius: 12px;
      object-fit: contain;
      display: block;
      background: transparent;
    }
    .mouth video { z-index: 2; display: none; }
    .mouth img { z-index: 1; }
    .mouth.playing video { display: block; }

    /* Ring animation overlay */
    .mouth-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(-90deg);
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 3;
      overflow: visible;
      display: block;
    }
    .mouth-overlay svg {
      width: 100%;
      height: 100%;
      display: block;
      overflow: visible;
    }
    .overlay-ring {
      fill: none;
      stroke: #000;
      stroke-linecap: round;
      transition: stroke-dashoffset 0.5s ease-in-out;
    }
    @media (prefers-reduced-motion: reduce) {
      .overlay-ring {
        transition: none !important;
      }
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(var(--grid-cols), 1fr);
      grid-auto-rows: 1fr;
      gap: var(--gap);
      width: 100%;
      align-content: start;
      z-index: 1;
      margin-top: 6px;
      box-sizing: border-box;
    }

    .letter {
      cursor: pointer;
      transition: transform 0.32s ease, opacity 0.28s ease;
      position: relative;
      z-index: 10;
      box-sizing: border-box;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      border: 3px solid;
      background: white;
      aspect-ratio: 1/1;
      overflow: hidden;
    }

    .letter img {
      width: 60%;
      height: 60%;
      object-fit: contain;
      user-select: none;
      pointer-events: none;
    }

    .letter.active { transform: scale(1.95); z-index: 500; }
    .letter.shrink { transform: scale(0.88); opacity: 0.85; }
    .letter.inactive { filter: grayscale(100%); opacity: 0.6; pointer-events: none; }

    .letter:nth-child(5n+1) { border-color: #FF6B6B; }
    .letter:nth-child(5n+2) { border-color: #4ECDC4; }
    .letter:nth-child(5n+3) { border-color: #45B7D1; }
    .letter:nth-child(5n+4) { border-color: #FFBE0B; }
    .letter:nth-child(5n+5) { border-color: #A5DD9B; }

    @media (max-width: 520px) {
      :root { --grid-cols: 4; }
      .mouth-wrapper { top: 70px; }
      .mouth-container { width: 140px; height: 140px; }
      .mouth { width: 110px; height: 110px; }
    }

    /* Confetti canvas */
    canvas#confettiCanvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 3000;
    }

  </style>
</head>
<body>
  <h1>Raahim's Arabic</h1>

  <div class="container">
    <!-- Mouth wrapper (sticky) contains progress bar + mouth so they move together -->
    <div class="mouth-wrapper" id="mouthWrapper">
      <!-- Circular progress container -->
      <div class="mouth-container" id="mouthContainer">
        <!-- Circular progress SVG -->
        <div class="circular-progress" id="circularProgress">
          <svg class="progress-ring" viewBox="0 0 100 100">
  <!-- We draw on a 100x100 viewBox; circles use r=47 so 6px stroke stays inside -->

  <!-- 1) Define the small 60° gap arc as a path.
       NOTE: This path is defined for the *unrotated* ring (gap from ~1 o’clock to 3 o’clock).
       Your .circular-progress has rotate(-60deg), so this ends up centered at the top (11–1 o’clock). -->
  <defs>
    <!-- Center (50,50), radius 47.
         Start at θ=300° (upper-right): (x≈73.5, y≈9.3)
         End   at θ=  0° (right):       (x=97,   y=50) -->
    <path id="gapArcPath"
          d="M 73.5 9.3 A 47 47 0 0 1 97 50" />
  </defs>

  <!-- 2) The background circle and the yellow progress arc -->
  <circle class="progress-ring-circle" cx="50" cy="50" r="47" />
  <circle class="progress-ring-value" id="progressRingValue" cx="50" cy="50" r="47" />

  <!-- 3) Curved text that sits along the gap arc -->
  <text class="gap-text" direction="ltr">
    <!-- center the text in the middle of the gap arc -->
    <textPath id="gapTextPath"
              href="#gapArcPath"
              startOffset="50%"
              text-anchor="middle"
              dominant-baseline="central">0 / 30</textPath>
  </text>
</svg>


        </div>
        
        <!-- Progress text in the center -->
        <div class="progress-text-container">
          <div class="progress-text" id="progressText">0 / 30</div>
        </div>
        
        <!-- Floating mouth circle -->
        <div class="circle mouth" id="mouth" aria-label="شكل الفم">
          <img id="mouthDefault" src="mouths/default.png" alt="Default mouth">
          <video id="mouthVideo" playsinline muted></video>

          <!-- Ring animation overlay -->
          <div class="mouth-overlay" id="mouthOverlay" aria-hidden="true">
            <svg id="mouthOverlaySvg" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid meet" viewBox="0 0 100 100">
                <!-- initial centered values; updateOverlayForSize() will set exact values -->
              <circle id="overlayCircle" class="overlay-ring" cx="50" cy="50" r="44" stroke-width="6"></circle>
            </svg>
          </div>    

        </div>
      </div>
    </div>

    <!-- Letters grid -->
    <div class="grid" id="grid" role="list"></div>
  </div>

  <!-- Confetti canvas -->
  <canvas id="confettiCanvas" aria-hidden="true"></canvas>

  <!-- Celebration sound (external URL so you don't need to add files locally) -->
  <audio id="celebrationSound" src="sounds/yay.mp3" preload="auto"></audio>

  <script>
    /*********************** Configuration ***********************/
    const LETTER_KEYS = [
      "alif","baa","taa","thaa","jeem",
      "haa","khaa","daal","zaal","raa",
      "zaa","seen","sheen","suad","duad",
      "tua","zua","ayn","ghayn","faa",
      "qaaf","kaaf","laam","meem","noon",
      "waw","hhaa","hamza","yaa","yaaa"
    ];
    const MIN_RESET_MS = 300;
    const META_TIMEOUT_MS = 1500;
    const AUDIO_FALLBACK_MS = 4500;
    const OVERALL_SAFE_MS = 12000;
    const MOUTH_SCALE = 1.5;
    const AUTO_RESET_AFTER_COMPLETE_MS = 7000; // auto-reset delay after 30/30
    const CONFETTI_DURATION_MS = 7000; // how long confetti runs

    /*********************** DOM refs ***********************/
    const grid = document.getElementById('grid');
    const mouth = document.getElementById('mouth');
    const mouthVideo = document.getElementById('mouthVideo');
    const mouthDefault = document.getElementById('mouthDefault');
    const progressRingValue = document.getElementById('progressRingValue');
    const progressText = document.getElementById('progressText');
    const gapTextPath = document.getElementById('gapTextPath');


    const mouthOverlay = document.getElementById('mouthOverlay');
    const mouthOverlaySvg = document.getElementById('mouthOverlaySvg');
    const overlayCircle = document.getElementById('overlayCircle');

    const confettiCanvas = document.getElementById('confettiCanvas');
    const confettiCtx = confettiCanvas.getContext('2d');

    const celebrationSound = document.getElementById('celebrationSound');

    /*********************** State ***********************/
    const state = {
      currentEl: null,
      currentKey: null,
      audio: null,
      audioTimer: null,
      metaTimeout: null,
      overallTimer: null,
      overlayCircumference: null,
      overlayActive: false,
      playedLetters: new Set(),
      completed: false,
      confettiPieces: [],
      confettiAnimationId: null,
      confettiTimeoutId: null,
      confettiFadeOpacity: 1,
      confettiFadeStartTime: null,
    };

    /*********************** Build grid ***********************/
    function buildGrid() {
      grid.innerHTML = '';
      LETTER_KEYS.forEach((k) => {
        const el = document.createElement('div');
        el.className = 'letter circle';
        el.setAttribute('data-key', k);
        el.setAttribute('role', 'listitem');
        el.innerHTML = `<img src="images/${k}.png" alt="${k}">`;
        el.addEventListener('click', () => onLetterClick(el, k));
        grid.appendChild(el);
      });
    }
    buildGrid();

    /*********************** Size sync ***********************/
    function syncMouthSize() {
      const sample = grid.querySelector('.letter');
      if (!sample) return;
      const rect = sample.getBoundingClientRect();
      const size = Math.max(48, Math.round(rect.width * MOUTH_SCALE));
      mouth.style.width = size + 'px';
      mouth.style.height = size + 'px';
      
      // Update container size to match
      const containerSize = Math.round(size * 1.3);
      document.getElementById('mouthContainer').style.width = containerSize + 'px';
      document.getElementById('mouthContainer').style.height = containerSize + 'px';
      
      updateOverlayForSize(size);
    }
    window.addEventListener('load', () => { syncMouthSize(); setTimeout(syncMouthSize, 60); });
    window.addEventListener('resize', () => { syncMouthSize(); resizeConfettiCanvas(); });

    /*********************** Timers / cleanup ***********************/
    function clearAudioTimer() { if (state.audioTimer) { clearTimeout(state.audioTimer); state.audioTimer = null; } }
    function clearMetaTimeout() { if (state.metaTimeout) { clearTimeout(state.metaTimeout); state.metaTimeout = null; } }
    function clearOverallTimer() { if (state.overallTimer) { clearTimeout(state.overallTimer); state.overallTimer = null; } }

    function unloadVideo() {
      try { mouthVideo.pause(); } catch(e){}
      try { mouthVideo.onended = null; mouthVideo.onerror = null; } catch(e){}
      try { mouthVideo.removeAttribute('src'); mouthVideo.load(); } catch(e){}
      mouth.classList.remove('playing');
      mouthVideo.style.display = 'none';
      try { mouthDefault.style.display = 'block'; } catch(e){}
      clearMetaTimeout();
    }

    function unloadAudio() {
      if (state.audio) {
        try {
          state.audio.onended = null;
          state.audio.onerror = null;
        } catch(e){}
        try { state.audio.pause(); state.audio.currentTime = 0; } catch(e){}
      }
      state.audio = null;
      clearAudioTimer();
    }

    function cancelPlayback(resetUI = true) {
      unloadAudio();
      unloadVideo();
      clearOverallTimer();
      overlayReset();
      if (resetUI && state.currentEl) {
        state.currentEl.classList.remove('active');
        state.currentEl = null;
        state.currentKey = null;
      }
      Array.from(grid.children).forEach(child => child.classList.remove('shrink'));
    }

    function immediateResetByAudio() {
      unloadVideo();
      if (state.currentEl) state.currentEl.classList.remove('active');
      state.currentEl = null;
      state.currentKey = null;
      Array.from(grid.children).forEach(child => child.classList.remove('shrink'));
      unloadAudio();
      clearOverallTimer();
      overlayReset();
    }

    window.addEventListener('pagehide', () => { cancelPlayback(true); stopConfettiImmediately(); });
    window.addEventListener('beforeunload', () => { cancelPlayback(true); stopConfettiImmediately(); });

    /*********************** Click handling ***********************/
    function onLetterClick(el, key) {
      cancelPlayback(true);

      state.currentEl = el;
      state.currentKey = key;
      el.classList.add('active');
      Array.from(grid.children).forEach(child => {
        if (child !== el) child.classList.add('shrink');
      });

      startAudioAndScheduleReset(key, el);
      startVideoOverlay(key);

      clearOverallTimer();
      state.overallTimer = setTimeout(() => {
        immediateResetByAudio();
      }, OVERALL_SAFE_MS);

      // Progress tracking: add key only once (Set)
      if (!state.playedLetters.has(key)) {
        state.playedLetters.add(key);
        updateProgress();
      }
    }

    /*********************** Audio handling ***********************/
    function startAudioAndScheduleReset(key, letterEl) {
      unloadAudio();
      clearAudioTimer();
      clearMetaTimeout();

      let audio;
      try {
        audio = new Audio(`sounds/${key}.mp3`);
        audio.preload = 'metadata';
      } catch (e) {
        state.audio = null;
        state.audioTimer = setTimeout(() => immediateResetByAudio(), AUDIO_FALLBACK_MS);
        return;
      }

      const onMeta = () => {
        try { audio.removeEventListener('loadedmetadata', onMeta); } catch(e){}
        const dur = (isFinite(audio.duration) && audio.duration > 0) ? audio.duration : null;
        scheduleResetFromDuration(dur, audio, letterEl);
      };
      audio.addEventListener('loadedmetadata', onMeta, { once: true });

      state.metaTimeout = setTimeout(() => {
        try { audio.removeEventListener('loadedmetadata', onMeta); } catch(e){}
        const dur = (isFinite(audio.duration) && audio.duration > 0) ? audio.duration : null;
        scheduleResetFromDuration(dur, audio, letterEl);
      }, META_TIMEOUT_MS);

      const p = audio.play();
      if (p && typeof p.then === 'function') {
        p.then(() => { overlayStart(); }).catch(() => { scheduleResetFromDuration(null, audio, letterEl); });
      }
      audio.onended = () => { immediateResetByAudio(); };
      audio.onerror = () => { immediateResetByAudio(); };

      state.audio = audio;
    }

    function scheduleResetFromDuration(durationSec, audioObj, letterEl) {
      clearMetaTimeout();
      clearAudioTimer();

      let ms;
      if (durationSec && isFinite(durationSec) && durationSec > 0) {
        ms = Math.max(MIN_RESET_MS, Math.ceil(durationSec * 1000) + 150);
      } else {
        ms = AUDIO_FALLBACK_MS;
      }

      state.audioTimer = setTimeout(() => {
        try { if (state.audio) { state.audio.pause(); state.audio.currentTime = 0; } } catch(e){}
        immediateResetByAudio();
      }, ms);
    }

    function startVideoOverlay(key) {
      try {
        mouth.classList.add('playing');
        mouthVideo.style.display = 'block';
        mouthVideo.src = `mouths/${key}.webm`;
        mouthVideo.load();

        const v = mouthVideo.play();
        if (v && typeof v.then === 'function') { v.catch(() => {}); }

        mouthVideo.onended = () => { unloadVideo(); };
        mouthVideo.onerror = () => { unloadVideo(); };
      } catch (e) { unloadVideo(); }
    }

    /*********************** Overlay animation functions ***********************/
    function updateOverlayForSize(sizePx) {
      const borderPx = 6; // match border
      mouthOverlaySvg.setAttribute('viewBox', `0 0 ${sizePx} ${sizePx}`);
      mouthOverlaySvg.setAttribute('width', sizePx);
      mouthOverlaySvg.setAttribute('height', sizePx);
      const cx = sizePx / 2;
      const cy = sizePx / 2;
      const r = Math.max(2, (sizePx / 2) - (borderPx * 0.5));
      overlayCircle.setAttribute('cx', cx.toString());
      overlayCircle.setAttribute('cy', cy.toString());
      overlayCircle.setAttribute('r', r.toString());
      overlayCircle.setAttribute('stroke-width', borderPx.toString());
      const circumference = 2 * Math.PI * r;
      overlayCircle.style.strokeDasharray = `${circumference}`;
      overlayCircle.style.strokeDashoffset = `${circumference}`;
      state.overlayCircumference = circumference;
    }

    function overlayStart() {
      if (!state.overlayCircumference) {
        const size = parseFloat(getComputedStyle(mouth).width) || 100;
        updateOverlayForSize(size);
      }
      if (state.overlayActive) return;

      const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      const c = state.overlayCircumference || 0;

      if (prefersReduced) {
        overlayCircle.style.strokeDashoffset = '0';
        state.overlayActive = true;
        return;
      }

      overlayCircle.style.strokeDashoffset = `${c}`;
      void overlayCircle.getBoundingClientRect();
      requestAnimationFrame(() => {
        overlayCircle.style.strokeDashoffset = '0';
        state.overlayActive = true;
      });
    }

    function overlayReset() {
      if (!state.overlayActive && !state.overlayCircumference) return;

      const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      const c = state.overlayCircumference || 0;

      if (prefersReduced) {
        overlayCircle.style.strokeDashoffset = `${c}`;
        state.overlayActive = false;
        return;
      }

      overlayCircle.style.strokeDashoffset = `${c}`;
      state.overlayActive = false;
    }

    /*********************** Circular Progress & Completion ***********************/
    function updateProgress() {
      const count = state.playedLetters.size;
      const total = LETTER_KEYS.length;
      const percent = (count / total) * 100;
      
     // Update circular progress
      // get radius from the SVG element so JS math always matches the SVG
      const radius = parseFloat(progressRingValue.getAttribute('r')) || 47;
      const circumference = 2 * Math.PI * radius;
      // Cover 80% of the circle (from 1 o'clock to 11 o'clock)
      const arcLength = circumference * (5/6);
      const offset = arcLength - (percent / 100) * arcLength;
      
      progressRingValue.style.strokeDasharray = `${arcLength} ${circumference}`;
      progressRingValue.style.strokeDashoffset = offset;
      
      // Update text
      progressText.textContent = `${count} / ${total}`;
      if (gapTextPath) {
        gapTextPath.textContent = `${count} / ${total}`;
      }


      // If completed and not yet handled, trigger celebration
      if (count >= total && !state.completed) {
        state.completed = true;
        setTimeout(() => {
          celebrate();
        }, 2000); // 2 second delay
        // auto reset after configured ms
        setTimeout(() => {
          resetProgress();
        }, AUTO_RESET_AFTER_COMPLETE_MS);
      }
    }

    function resetProgress() {
      // stop any confetti if still running
      stopConfetti();
      state.playedLetters.clear();
      state.completed = false;
      updateProgress();
    }

    /*********************** Confetti (canvas) ***********************/
    function resizeConfettiCanvas() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      confettiCanvas.width = Math.floor(window.innerWidth * dpr);
      confettiCanvas.height = Math.floor(window.innerHeight * dpr);
      confettiCanvas.style.width = window.innerWidth + "px";
      confettiCanvas.style.height = window.innerHeight + "px";
      confettiCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    resizeConfettiCanvas();

    function createConfettiPieces(amount = 200) {
    const w = window.innerWidth;
    const h = window.innerHeight;
    const pieces = [];
    for (let i = 0; i < amount; i++) {
    pieces.push({
      x: Math.random() * w,
      y: Math.random() * -h * 0.8, // Start higher up
      vx: (Math.random() - 0.5) * 8, // More horizontal spread
      vy: Math.random() * 5 + 3, // Faster falling
      r: Math.random() * 10 + 8, // Bigger pieces (was 4-10, now 8-18)
      rot: Math.random() * 360,
      rotSpeed: (Math.random() - 0.5) * 12, // Faster rotation
      color: `hsl(${Math.floor(Math.random() * 360)},90%,60%)`, // More saturated
      shape: Math.floor(Math.random() * 3), // Different shapes
    });
  }
  return pieces;
}

    function drawConfettiFrame() {
  // Clear with transparency to allow fade effect
  confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
  
  // Set global alpha for fade effect
  confettiCtx.globalAlpha = state.confettiFadeOpacity;
  
  const pieces = state.confettiPieces;
  
  for (let i = 0; i < pieces.length; i++) {
    const p = pieces[i];
    confettiCtx.save();
    confettiCtx.translate(p.x, p.y);
    confettiCtx.rotate(p.rot * Math.PI / 180);
    confettiCtx.fillStyle = p.color;
    
    // Draw different shapes
    switch(p.shape) {
      case 0: // Rectangle (original)
        confettiCtx.fillRect(-p.r/2, -p.r/2, p.r, p.r*0.6);
        break;
      case 1: // Circle
        confettiCtx.beginPath();
        confettiCtx.arc(0, 0, p.r/2, 0, Math.PI * 2);
        confettiCtx.fill();
        break;
      case 2: // Triangle
        confettiCtx.beginPath();
        confettiCtx.moveTo(0, -p.r/2);
        confettiCtx.lineTo(p.r/2, p.r/2);
        confettiCtx.lineTo(-p.r/2, p.r/2);
        confettiCtx.closePath();
        confettiCtx.fill();
        break;
    }
    
    confettiCtx.restore();

    // Update position
    p.x += p.vx;
    p.y += p.vy;
    p.rot += p.rotSpeed;
    
    // Add slight gravity effect
    p.vy += 0.05;

    // Recycle when out of screen
    if (p.y > window.innerHeight + 20 || p.x < -20 || p.x > window.innerWidth + 20) {
      p.y = Math.random() * -window.innerHeight * 0.5;
      p.x = Math.random() * window.innerWidth;
      p.vx = (Math.random() - 0.5) * 8;
      p.vy = Math.random() * 4 + 2;
    }
  }
  
  // Reset global alpha
  confettiCtx.globalAlpha = 1;
  
  // Only continue animation if not in fade mode
  if (state.confettiFadeStartTime === null) {
    state.confettiAnimationId = requestAnimationFrame(drawConfettiFrame);
  }
}
    function startConfetti() {
  // accessibility: respect prefers-reduced-motion
  if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;
  stopConfettiImmediately();
  resizeConfettiCanvas();
  
  // Reset fade state
  state.confettiFadeOpacity = 1;
  state.confettiFadeStartTime = null;
  
  state.confettiPieces = createConfettiPieces(200);
  state.confettiAnimationId = requestAnimationFrame(drawConfettiFrame);
  // stop after CONFETTI_DURATION_MS automatically
  state.confettiTimeoutId = setTimeout(() => stopConfetti(), CONFETTI_DURATION_MS);
}
    function stopConfetti() {
  if (state.confettiAnimationId) {
    cancelAnimationFrame(state.confettiAnimationId);
    state.confettiAnimationId = null;
  }
  if (state.confettiTimeoutId) {
    clearTimeout(state.confettiTimeoutId);
    state.confettiTimeoutId = null;
  }
  
  // Start fade out animation instead of immediately clearing
  state.confettiFadeOpacity = 1;
  state.confettiFadeStartTime = Date.now();
  
  // Start fade animation
  function fadeOut() {
    const elapsed = Date.now() - state.confettiFadeStartTime;
    const fadeDuration = 2500; // 2.5 seconds
    
    if (elapsed < fadeDuration) {
      // Calculate current opacity
      state.confettiFadeOpacity = 1 - (elapsed / fadeDuration);
      
      // Continue animation
      state.confettiAnimationId = requestAnimationFrame(fadeOut);
    } else {
      // Fade complete, clear everything
      state.confettiFadeOpacity = 0;
      confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
      state.confettiPieces = [];
      state.confettiAnimationId = null;
      return;
    }
    
    // Draw with current opacity
    drawConfettiFrame();
  }
  
  // Start the fade animation
  state.confettiAnimationId = requestAnimationFrame(fadeOut);
}

    function stopConfettiImmediately() {
  if (state.confettiAnimationId) cancelAnimationFrame(state.confettiAnimationId);
  if (state.confettiTimeoutId) clearTimeout(state.confettiTimeoutId);
  state.confettiAnimationId = null;
  state.confettiTimeoutId = null;
  state.confettiPieces = [];
  state.confettiFadeOpacity = 1;
  state.confettiFadeStartTime = null;
  confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
}

    /*********************** Celebration ***********************/
    function celebrate() {
      // play celebration sound (respect user's reduced-motion preference for visuals only)
      try {
        celebrationSound.currentTime = 0;
        celebrationSound.play().catch(()=>{ /* play might be blocked until user interacts; that's fine */ });
      } catch (e) {}

      startConfetti();
    }

    /*********************** Initialization ***********************/
    // initialize progress to 0
    updateProgress();

    // ensure overlay sizing after load
    window.addEventListener('load', () => {
      setTimeout(() => {
        const sizePx = parseFloat(getComputedStyle(mouth).width) || 180;
        updateOverlayForSize(sizePx);
      }, 100);
    });

    // make sure confetti canvas resizes on orientation change
    window.addEventListener('orientationchange', resizeConfettiCanvas);
  </script>
</body>
</html>
