<!DOCTYPE html>
<html dir="rtl" lang="ar">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Raahim's Arabic</title>
  <style>
    :root { --gap: 10px; --max-width: 900px; --grid-cols: 5; }

    body {
      font-family: 'Comic Sans MS', cursive, sans-serif;
      background: #f5f5f5;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      box-sizing: border-box;
    }

    h1 {
      color: #2e8b57;
      margin: 0 0 18px 0;
      position: sticky;
      top: 0;
      background: #f5f5f5;
      padding: 10px 20px;
      border-radius: 0 0 15px 15px;
      z-index: 1000;
      width: 100%;
      text-align: center;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    }

    .container {
      width: 100%;
      max-width: var(--max-width);
      display: grid;
      grid-template-rows: auto 1fr;
      gap: 18px;
      align-items: start;
      box-sizing: border-box;
    }

    /* wrapper that moves with scroll (holds progress + mouth) */
    .mouth-wrapper {
      position: sticky;
      top: 80px; /* below header */
      z-index: 2000;
      width: 100%;
      max-width: var(--max-width);
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      pointer-events: none; /* let clicks through except on interactive children */
    }

    /* Floating mouth circle with circular progress */
    .mouth-container {
      position: relative;
      width: 180px;
      height: 180px;
      margin: 0 auto 18px auto;
      pointer-events: auto;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .circular-progress {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      transform: rotate(-60deg); /* Start at top (clean) */
      shape-rendering: geometricPrecision;
    }

    .progress-ring {
      width: 100%;
      height: 100%;
      shape-rendering: geometricPrecision;
    }

    .progress-ring-circle {
      fill: none;
      stroke: transparent;
      stroke-width: 6;
    }

    .progress-ring-value {
      fill: none;
      stroke: #FFD700;
      stroke-width: 6;
      stroke-linecap: round;
      transition: stroke-dashoffset 0.45s cubic-bezier(.2,.9,.2,1);
    }

    .progress-text-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      pointer-events: none;
    }

    .progress-text {
      font-size: 14px;
      color: #333;
      margin: 0;
    }


    /* Curved text that lives in the arc gap */
.gap-text {
  font-size: 8px;
  font-weight: 700;
  fill: #333;
  pointer-events: none; /* don’t steal clicks */
}


    .mouth {
      transition: transform 0.18s ease;
      background: white;
      border-radius: 50%;
      border: 6px solid #FFFF00; /* Thicker border */
      display: flex;
      align-items: center;
      justify-content: center;
      aspect-ratio: 1/1;
      overflow: hidden;
      box-sizing: border-box;
      box-shadow: 0 4px 15px rgba(0,0,0,0.5);
      position: relative;
      width: 140px; /* default will be overridden by JS syncMouthSize */
      height: 140px;
      z-index: 2001;
    }
    .mouth.playing { transform: scale(1.03); }

    .mouth img, .mouth video {
      position: absolute;
      inset: 6%;
      width: 88%;
      height: 88%;
      border-radius: 12px;
      object-fit: contain;
      display: block;
      background: transparent;
    }
    .mouth video { z-index: 2; display: none; }
    .mouth img { z-index: 1; }
    .mouth.playing video { display: block; }

    /* Ring animation overlay */
    .mouth-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(-90deg);
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 3;
      overflow: visible;
      display: block;
    }
    .mouth-overlay svg {
      width: 100%;
      height: 100%;
      display: block;
      overflow: visible;
    }
    .overlay-ring {
      fill: none;
      stroke: #000;
      stroke-linecap: round;
      transition: stroke-dashoffset 0.5s ease-in-out;
    }
    @media (prefers-reduced-motion: reduce) {
      .overlay-ring {
        transition: none !important;
      }
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(var(--grid-cols), 1fr);
      grid-auto-rows: 1fr;
      gap: var(--gap);
      width: 100%;
      align-content: start;
      z-index: 1;
      margin-top: 6px;
      box-sizing: border-box;
    }

    .letter {
      cursor: pointer;
      transition: transform 0.32s ease, opacity 0.28s ease;
      position: relative;
      z-index: 10;
      box-sizing: border-box;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;

      border: 3px solid transparent;
      background: white;
      aspect-ratio: 1/1;
      overflow: hidden;

     
      background-image:
      linear-gradient(#ffffff, #ffffff),
      linear-gradient(to right,
      var(--left-border) 40%,       /* solid left */
      var(--right-border) 60%       /* solid right */
    );

      background-origin: padding-box, border-box;
      background-clip: padding-box, border-box;
      /* vendor prefix for older WebKit if needed */
      -webkit-background-clip: padding-box, border-box;

    }

    .letter img {
      width: 60%;
      height: 60%;
      object-fit: contain;
      user-select: none;
      pointer-events: none;
    }

    .letter.previous {
      filter: grayscale(100%);
      opacity: 0.6;
      /* pointer-events stays enabled so it remains clickable */
}


    .letter.active { transform: scale(1.95); z-index: 500; }
    .letter.shrink { transform: scale(0.88); opacity: 0.85; }
    .letter.inactive { filter: grayscale(100%); opacity: 0.6; pointer-events: none; }

    

    @media (max-width: 520px) {
      :root { --grid-cols: 4; }
      .mouth-wrapper { top: 70px; }
      .mouth-container { width: 140px; height: 140px; }
      .mouth { width: 110px; height: 110px; }
    }

    /* Confetti canvas */
    canvas#confettiCanvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 3000;
    }

    /* -------------------- Tick badge layer -------------------- */
#tickLayer {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  background: transparent;
  height: 100%;
  pointer-events: none; /* clicks pass through */
  z-index: 1500;        /* above letters/mouth overlay but below confetti (confetti was 3000) */
}

/* Single tick badge (absolute page coords inside tickLayer) */
.tick-badge {
  position: absolute;
  background: transparent;
  transform: translate(-50%, -50%); /* center by left/top */
  pointer-events: none;
  display: none; /* toggled by JS */
  z-index: 2501;
  will-change: transform, opacity;
}

/* video & png use the badge size */
.tick-badge video,
.tick-badge img {
  display: block;
  width: 100%;
  height: 100%;
  object-fit: contain;
  pointer-events: none;
  user-select: none;
  -webkit-user-drag: none;
  background: transparent;
}


  </style>
</head>
<body>
  <h1>Raahim's Arabic</h1>

  <div class="container">
    <!-- Mouth wrapper (sticky) contains progress bar + mouth so they move together -->
    <div class="mouth-wrapper" id="mouthWrapper">
      <!-- Circular progress container -->
      <div class="mouth-container" id="mouthContainer">
        <!-- Circular progress SVG -->
        <div class="circular-progress" id="circularProgress">
          <svg class="progress-ring" viewBox="0 0 100 100">
  <!-- We draw on a 100x100 viewBox; circles use r=47 so 6px stroke stays inside -->

  <!-- 1) Define the small 60° gap arc as a path.
       NOTE: This path is defined for the *unrotated* ring (gap from ~1 o’clock to 3 o’clock).
       Your .circular-progress has rotate(-60deg), so this ends up centered at the top (11–1 o’clock). -->
  <defs>
    <!-- Center (50,50), radius 47.
         Start at θ=300° (upper-right): (x≈73.5, y≈9.3)
         End   at θ=  0° (right):       (x=97,   y=50) -->
    <path id="gapArcPath"
          d="M 73.5 9.3 A 47 47 0 0 1 97 50" />
  </defs>

  <!-- 2) The background circle and the yellow progress arc -->
  <circle class="progress-ring-circle" cx="50" cy="50" r="47" />
  <circle class="progress-ring-value" id="progressRingValue" cx="50" cy="50" r="47" />

  <!-- 3) Curved text that sits along the gap arc -->
  <text class="gap-text" direction="ltr">
    <!-- center the text in the middle of the gap arc -->
    <textPath id="gapTextPath"
              href="#gapArcPath"
              startOffset="50%"
              text-anchor="middle"
              dominant-baseline="central">0 / 30</textPath>
  </text>
</svg>


        </div>
        
        <!-- Progress text in the center -->
        <div class="progress-text-container">
          <div class="progress-text" id="progressText">0 / 30</div>
        </div>
        
        <!-- Floating mouth circle -->
        <div class="circle mouth" id="mouth" aria-label="شكل الفم">
          <img id="mouthDefault" src="mouths/default.png" alt="Default mouth">
          <video id="mouthVideo" playsinline muted></video>

          <!-- Ring animation overlay -->
          <div class="mouth-overlay" id="mouthOverlay" aria-hidden="true">
            <svg id="mouthOverlaySvg" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid meet" viewBox="0 0 100 100">
                <!-- initial centered values; updateOverlayForSize() will set exact values -->
              <circle id="overlayCircle" class="overlay-ring" cx="50" cy="50" r="44" stroke-width="6"></circle>
            </svg>
          </div>    

        </div>
      </div>
    </div>

    <!-- Letters grid -->
    <div class="grid" id="grid" role="list"></div>
  </div>

  <!-- Tick UI layer - badges live here (keeps them outside letter filters) -->
<div id="tickLayer" aria-hidden="true"></div>


  <!-- Confetti canvas -->
  <canvas id="confettiCanvas" aria-hidden="true"></canvas>

  <!-- Celebration sound (external URL so you don't need to add files locally) -->
  <audio id="celebrationSound" src="sounds/yay.mp3" preload="auto"></audio>

  <script>
    /*********************** Configuration ***********************/
    const LETTER_KEYS = [
      "alif","baa","taa","thaa","jeem",
      "haa","khaa","daal","zaal","raa",
      "zaa","seen","sheen","suad","duad",
      "tua","zua","ayn","ghayn","faa",
      "qaaf","kaaf","laam","meem","noon",
      "waw","hhaa","hamza","yaa","yaaa"
    ];

  const COLORS = [
     ["#000000","#000000"],
     ["#000000","#000000"],
     ["#000000","#000000"],
     ["#4633CC","#000000"],
     ["#000000","#000000"],
     ["#000000","#000000"],
     ["#FFFF12","#FFFF12"],
     ["#000000","#000000"],
     ["#4633CC","#000000"],
     ["#FFFF12","#FFFF12"],
     ["#DB0000","#000000"],
     ["#DB0000","#000000"],
     ["#000000","#000000"],
     ["#DB0000","#FFFF12"],
     ["#FFFF12","#FFFF12"],
     ["#FFFF12","#FFFF12"],
     ["#4633CC","#FFFF12"],
     ["#000000","#000000"],
     ["#FFFF12","#FFFF12"],
     ["#000000","#000000"],
     ["#FFFF12","#FFFF12"],
     ["#000000","#000000"],
     ["#000000","#000000"],
     ["#000000","#000000"],
     ["#000000","#000000"],
     ["#000000","#000000"],
     ["#000000","#000000"],
     ["#000000","#000000"],
     ["#000000","#000000"],
     ["#000000","#000000"],

];



    const MIN_RESET_MS = 300;
    const META_TIMEOUT_MS = 1500;
    const AUDIO_FALLBACK_MS = 4500;
    const OVERALL_SAFE_MS = 12000;
    const MOUTH_SCALE = 1.5;
    const AUTO_RESET_AFTER_COMPLETE_MS = 7000; // auto-reset delay after 30/30
    const CONFETTI_DURATION_MS = 7000; // how long confetti runs

    /*********************** DOM refs ***********************/
    const grid = document.getElementById('grid');
    const mouth = document.getElementById('mouth');
    const mouthVideo = document.getElementById('mouthVideo');
    const mouthDefault = document.getElementById('mouthDefault');
    const progressRingValue = document.getElementById('progressRingValue');
    const progressText = document.getElementById('progressText');
    const gapTextPath = document.getElementById('gapTextPath');

    const mouthOverlay = document.getElementById('mouthOverlay');
    const mouthOverlaySvg = document.getElementById('mouthOverlaySvg');
    const overlayCircle = document.getElementById('overlayCircle');

    const confettiCanvas = document.getElementById('confettiCanvas');
    const confettiCtx = confettiCanvas.getContext('2d');

    const celebrationSound = document.getElementById('celebrationSound');

    const tickLayer = document.getElementById('tickLayer') || (() => {
    const el = document.createElement('div');
      el.id = 'tickLayer';
      el.setAttribute('aria-hidden','true');
      el.style.position = 'absolute';
      el.style.top = '0';
      el.style.left = '0';
      el.style.width = '100%';
      el.style.height = '100%';
      el.style.pointerEvents = 'none';
      el.style.zIndex = '2500';
      document.body.appendChild(el);
    return el;
  })();


    /*********************** State ***********************/
    const state = {
      currentEl: null,
      currentKey: null,
      audio: null,
      audioTimer: null,
      metaTimeout: null,
      overallTimer: null,
      overlayCircumference: null,
      overlayActive: false,
      playedLetters: new Set(),
      completed: false,
      confettiPieces: [],
      confettiAnimationId: null,
      confettiTimeoutId: null,
      confettiFadeOpacity: 1,
      confettiFadeStartTime: null,
    };

    /*********************** Build grid ***********************/
    
    function buildGrid() {
      grid.innerHTML = '';
      LETTER_KEYS.forEach((k, i) => {
    const color = COLORS[i % COLORS.length]; // map color by index
    const el = document.createElement('div');
    el.className = 'letter circle';
    el.setAttribute('data-key', k);
    el.setAttribute('role', 'listitem');
    el.innerHTML = `<img src="images/${k}.png" alt="${k}">`;

    // Determine left/right colours (support legacy single-string fallback)
    const pair = COLORS[i % COLORS.length];
    let left, right;
    if (Array.isArray(pair)) {
      [left, right] = pair;
    } else {
      left = right = pair || '#000';
    }

    // apply border split via CSS custom properties
    el.style.border = '4.5px solid transparent';
    el.style.setProperty('--left-border', left);
    el.style.setProperty('--right-border', right);

    // Create the tick-badge (kept outside the letter so letter filters don't affect it)
    const tickContainer = document.createElement('div');
    tickContainer.className = 'tick-badge';
    tickContainer.setAttribute('data-key', k);
    tickContainer.style.display = 'none'; // shown later by JS

    // Create tick video element
    const tickVideo = document.createElement('video');
        // Do NOT set .src immediately on older Safari fallback approach below.
        // We'll set src on browsers that support WebM.
    tickVideo.preload = 'auto';
    tickVideo.playsInline = true;
    tickVideo.muted = false;               // required for autoplay in many browsers
    tickVideo.style.display = 'none';     // hide until first frame ready
    tickVideo.style.background = 'transparent';
    tickVideo.setAttribute('aria-hidden', 'true');

                                        // Create tick image fallback
    const tickImg = document.createElement('img');
    tickImg.src = `mouths/tick.png`;
    tickImg.alt = 'tick';
    tickImg.style.display = 'none';
    tickImg.setAttribute('aria-hidden', 'true');

      // Only attach webm src if browser claims to support it (basic capability test)
    const canPlayWebm = document.createElement('video').canPlayType('video/webm; codecs="vp9,opus"') ||
                    document.createElement('video').canPlayType('video/webm; codecs="vp9"');
if (canPlayWebm) {
  tickVideo.src = `mouths/tick.webm`;
} else {
  // fallback immediately to png for browsers that can't play webm/vp9
  tickImg.style.display = 'block';
}


    // When the webm finishes, hide the video and show the png placeholder
    tickVideo.onended = () => {
      try { tickVideo.style.display = 'none'; } catch(e) {}
      try { tickImg.style.display = 'block'; } catch(e) {}
      el._tick && (el._tick.shown = true);
      // ensure the container remains visible if showing the image
      tickContainer.style.display = 'block';
    };

    tickContainer.appendChild(tickVideo);
    tickContainer.appendChild(tickImg);
    tickLayer.appendChild(tickContainer);

    // Attach tick metadata to the letter element so we can schedule/clear it later
    el._tick = {
      container: tickContainer,
      video: tickVideo,
      img: tickImg,
      timeout: null,
      shown: false
    };

    // Click handler (existing)
    el.addEventListener('click', () => onLetterClick(el, k));
    grid.appendChild(el);
  });

  // After building, position all tick badges (they will be sized off the letters)
  requestAnimationFrame(() => updateAllTickPositions());
}



    buildGrid();

    /*********************** Size sync ***********************/
    function syncMouthSize() {
      const sample = grid.querySelector('.letter');
      if (!sample) return;
      const rect = sample.getBoundingClientRect();
      const size = Math.max(48, Math.round(rect.width * MOUTH_SCALE));
      mouth.style.width = size + 'px';
      mouth.style.height = size + 'px';
      
      // Update container size to match
      const containerSize = Math.round(size * 1.3);
      document.getElementById('mouthContainer').style.width = containerSize + 'px';
      document.getElementById('mouthContainer').style.height = containerSize + 'px';
      
      updateOverlayForSize(size);
    }
    window.addEventListener('load', () => { syncMouthSize(); setTimeout(syncMouthSize, 60); });
    window.addEventListener('resize', () => { syncMouthSize(); resizeConfettiCanvas(); });

    /*********************** Timers / cleanup ***********************/
    function clearAudioTimer() { if (state.audioTimer) { clearTimeout(state.audioTimer); state.audioTimer = null; } }
    function clearMetaTimeout() { if (state.metaTimeout) { clearTimeout(state.metaTimeout); state.metaTimeout = null; } }
    function clearOverallTimer() { if (state.overallTimer) { clearTimeout(state.overallTimer); state.overallTimer = null; } }

    function unloadVideo() {
      try { mouthVideo.pause(); } catch(e){}
      try { mouthVideo.onended = null; mouthVideo.onerror = null; } catch(e){}
      try { mouthVideo.removeAttribute('src'); mouthVideo.load(); } catch(e){}
      mouth.classList.remove('playing');
      mouthVideo.style.display = 'none';
      try { mouthDefault.style.display = 'block'; } catch(e){}
      clearMetaTimeout();
    }

    function unloadAudio() {
      if (state.audio) {
        try {
          state.audio.onended = null;
          state.audio.onerror = null;
        } catch(e){}
        try { state.audio.pause(); state.audio.currentTime = 0; } catch(e){}
      }
      state.audio = null;
      clearAudioTimer();
    }

    function cancelPlayback(resetUI = true) {
      unloadAudio();
      unloadVideo();
      clearOverallTimer();
      overlayReset();
      if (resetUI && state.currentEl) {
        state.currentEl.classList.remove('active');
        state.currentEl = null;
        state.currentKey = null;
      }
      Array.from(grid.children).forEach(child => child.classList.remove('shrink'));
    }

    function immediateResetByAudio() {
      unloadVideo();
      if (state.currentEl) state.currentEl.classList.remove('active');
      state.currentEl = null;
      state.currentKey = null;
      Array.from(grid.children).forEach(child => child.classList.remove('shrink'));
      unloadAudio();
      clearOverallTimer();
      overlayReset();
    }

    window.addEventListener('pagehide', () => { cancelPlayback(true); stopConfettiImmediately(); });
    window.addEventListener('beforeunload', () => { cancelPlayback(true); stopConfettiImmediately(); });

    // ------------------------- Click handler (fixed) -------------------------
function onLetterClick(el, key) {
  cancelPlayback(true);

  state.currentEl = el;
  state.currentKey = key;
  el.classList.add('active');
  Array.from(grid.children).forEach(child => {
    if (child !== el) child.classList.add('shrink');
  });

  // Clear any existing timeout on this letter
  if (el.grayscaleTimeout) {
    clearTimeout(el.grayscaleTimeout);
    el.grayscaleTimeout = null;
  }


  // clear any previously scheduled tick for this same letter (we'll schedule a fresh one)
  if (el._tick && el._tick.timeout) {
  clearTimeout(el._tick.timeout);
  el._tick.timeout = null;
}



  // Schedule grayscale effect after 4 seconds and *store the id* so we can cancel it
  el.grayscaleTimeout = setTimeout(() => {
    // If timeout wasn't cleared, apply class and cleanup reference
    el.classList.add('previous');
    el.grayscaleTimeout = null;
  }, 4000);

  startAudioAndScheduleReset(key, el);
  startVideoOverlay(key);

          // schedule the tick badge for this letter (4s after click)
  scheduleTickForLetter(el);





  clearOverallTimer();
  state.overallTimer = setTimeout(() => {
    immediateResetByAudio();
  }, OVERALL_SAFE_MS);

  // Progress tracking: add key only once (Set)
  if (!state.playedLetters.has(key)) {
    state.playedLetters.add(key);
    updateProgress();
  }
}


    /*********************** Audio handling ***********************/
    function startAudioAndScheduleReset(key, letterEl) {
      unloadAudio();
      clearAudioTimer();
      clearMetaTimeout();

      let audio;
      try {
        audio = new Audio(`sounds/${key}.mp3`);
        audio.preload = 'metadata';
      } catch (e) {
        state.audio = null;
        state.audioTimer = setTimeout(() => immediateResetByAudio(), AUDIO_FALLBACK_MS);
        return;
      }

      const onMeta = () => {
        try { audio.removeEventListener('loadedmetadata', onMeta); } catch(e){}
        const dur = (isFinite(audio.duration) && audio.duration > 0) ? audio.duration : null;
        scheduleResetFromDuration(dur, audio, letterEl);
      };
      audio.addEventListener('loadedmetadata', onMeta, { once: true });

      state.metaTimeout = setTimeout(() => {
        try { audio.removeEventListener('loadedmetadata', onMeta); } catch(e){}
        const dur = (isFinite(audio.duration) && audio.duration > 0) ? audio.duration : null;
        scheduleResetFromDuration(dur, audio, letterEl);
      }, META_TIMEOUT_MS);

      const p = audio.play();
      if (p && typeof p.then === 'function') {
        p.then(() => { overlayStart(); }).catch(() => { scheduleResetFromDuration(null, audio, letterEl); });
      }
      audio.onended = () => { immediateResetByAudio(); };
      audio.onerror = () => { immediateResetByAudio(); };

      state.audio = audio;
    }

    function scheduleResetFromDuration(durationSec, audioObj, letterEl) {
      clearMetaTimeout();
      clearAudioTimer();

      let ms;
      if (durationSec && isFinite(durationSec) && durationSec > 0) {
        ms = Math.max(MIN_RESET_MS, Math.ceil(durationSec * 1000) + 150);
      } else {
        ms = AUDIO_FALLBACK_MS;
      }

      state.audioTimer = setTimeout(() => {
        try { if (state.audio) { state.audio.pause(); state.audio.currentTime = 0; } } catch(e){}
        immediateResetByAudio();
      }, ms);
    }

    function startVideoOverlay(key) {
      try {
        mouth.classList.add('playing');
        mouthVideo.style.display = 'block';
        mouthVideo.src = `mouths/${key}.webm`;
        mouthVideo.load();

        const v = mouthVideo.play();
        if (v && typeof v.then === 'function') { v.catch(() => {}); }

        mouthVideo.onended = () => { unloadVideo(); };
        mouthVideo.onerror = () => { unloadVideo(); };
      } catch (e) { unloadVideo(); }
    }

    /*********************** Overlay animation functions ***********************/
    function updateOverlayForSize(sizePx) {
      const borderPx = 6; // match border
      mouthOverlaySvg.setAttribute('viewBox', `0 0 ${sizePx} ${sizePx}`);
      mouthOverlaySvg.setAttribute('width', sizePx);
      mouthOverlaySvg.setAttribute('height', sizePx);
      const cx = sizePx / 2;
      const cy = sizePx / 2;
      const r = Math.max(2, (sizePx / 2) - (borderPx * 0.5));
      overlayCircle.setAttribute('cx', cx.toString());
      overlayCircle.setAttribute('cy', cy.toString());
      overlayCircle.setAttribute('r', r.toString());
      overlayCircle.setAttribute('stroke-width', borderPx.toString());
      const circumference = 2 * Math.PI * r;
      overlayCircle.style.strokeDasharray = `${circumference}`;
      overlayCircle.style.strokeDashoffset = `${circumference}`;
      state.overlayCircumference = circumference;
    }

    function overlayStart() {
      if (!state.overlayCircumference) {
        const size = parseFloat(getComputedStyle(mouth).width) || 100;
        updateOverlayForSize(size);
      }
      if (state.overlayActive) return;

      const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      const c = state.overlayCircumference || 0;

      if (prefersReduced) {
        overlayCircle.style.strokeDashoffset = '0';
        state.overlayActive = true;
        return;
      }

      overlayCircle.style.strokeDashoffset = `${c}`;
      void overlayCircle.getBoundingClientRect();
      requestAnimationFrame(() => {
        overlayCircle.style.strokeDashoffset = '0';
        state.overlayActive = true;
      });
    }

    function overlayReset() {
      if (!state.overlayActive && !state.overlayCircumference) return;

      const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      const c = state.overlayCircumference || 0;

      if (prefersReduced) {
        overlayCircle.style.strokeDashoffset = `${c}`;
        state.overlayActive = false;
        return;
      }

      overlayCircle.style.strokeDashoffset = `${c}`;
      state.overlayActive = false;
    }

    /*********************** Circular Progress & Completion ***********************/
    function updateProgress() {
      const count = state.playedLetters.size;
      const total = LETTER_KEYS.length;
      const percent = (count / total) * 100;
      
     // Update circular progress
      // get radius from the SVG element so JS math always matches the SVG
      const radius = parseFloat(progressRingValue.getAttribute('r')) || 47;
      const circumference = 2 * Math.PI * radius;
      // Cover 80% of the circle (from 1 o'clock to 11 o'clock)
      const arcLength = circumference * (5/6);
      const offset = arcLength - (percent / 100) * arcLength;
      
      progressRingValue.style.strokeDasharray = `${arcLength} ${circumference}`;
      progressRingValue.style.strokeDashoffset = offset;
      
      // Update text
      progressText.textContent = `${count} / ${total}`;
      if (gapTextPath) {
        gapTextPath.textContent = `${count} / ${total}`;
      }


      // If completed and not yet handled, trigger celebration
      if (count >= total && !state.completed) {
        state.completed = true;
        setTimeout(() => {
          celebrate();
        }, 3700); // 2 second delay
        // auto reset after configured ms
        setTimeout(() => {
          resetProgress();
        }, AUTO_RESET_AFTER_COMPLETE_MS);
      }
    }


    // -------------------- Tick badge helpers --------------------

function positionTickForLetter(letterEl) {
  if (!letterEl || !letterEl._tick || !letterEl._tick.container) return;
  const t = letterEl._tick;
  const rect = letterEl.getBoundingClientRect();
  const w = rect.width;
  const h = rect.height;
  const cx = rect.left + w / 2 + window.scrollX;
  const cy = rect.top + h / 2 + window.scrollY;

  // circle radius (we assume letter is circular).
  const R = Math.min(w, h) / 2;

  // Angle system: degrees measured clockwise from top (0° = 12 o'clock).
  const angleDeg = 133; // per your spec (between 4 and 5 o'clock)
  const rad = angleDeg * Math.PI / 180;

  // Place the center of the tick on the circumference (makes it half-on/half-off visually).
  const d = R;

  // Convert to page coords (screen Y positive down). Mapping derived for clockwise-from-top:
  const x = cx + Math.sin(rad) * d;
  const y = cy - Math.cos(rad) * d;

  // pick badge size relative to letter size
  const tickSize = Math.max(18, Math.round(w * 0.36)); // tweak multiplier if you want bigger/smaller

  t.container.style.left = x + 'px';
  t.container.style.top = y + 'px';
  t.container.style.width = tickSize + 'px';
  t.container.style.height = tickSize + 'px';
}

function updateAllTickPositions() {
  // iterate letters
  Array.from(grid.children).forEach(letter => {
    if (letter._tick) positionTickForLetter(letter);
  });
}

// schedule tick webm to play 4s after clicking the letter
function scheduleTickForLetter(letterEl) {
  if (!letterEl || !letterEl._tick) return;
  const t = letterEl._tick;
  if (t.shown) return; // already shown/persisted

  // clear existing scheduled tick for this letter
  if (t.timeout) {
    clearTimeout(t.timeout);
    t.timeout = null;
  }

  // schedule at same 4 seconds as your grayscale (explicitly set)
  t.timeout = setTimeout(() => {
    playTickForLetter(letterEl);
    t.timeout = null;
  }, 4000);
}

    function playTickForLetter(letterEl) {
  if (!letterEl || !letterEl._tick) return;
  const t = letterEl._tick;

  // If placeholder already shown, show it and return
  if (t.shown) {
    t.container.style.display = 'block';
    t.img.style.display = 'block';
    return;
  }

  // Show container but keep video hidden until we have a frame
  t.container.style.display = 'block';
  t.img.style.display = 'none';
  t.video.style.display = 'none';

  // Safety flag & fallback
  let shown = false;
  function showVideo() {
    if (shown) return;
    shown = true;
    try { t.video.style.display = 'block'; } catch(e){}
    try { t.img.style.display = 'none'; } catch(e){}
  }

  // If browser supports requestVideoFrameCallback, wait for first painted frame
  if (t.video.requestVideoFrameCallback) {
    const p = t.video.play();
    if (p && typeof p.then === 'function') {
      p.then(() => {
        try {
          t.video.requestVideoFrameCallback(() => {
            showVideo();
          });
        } catch (e) {
          // fallback to loadeddata
          t.video.addEventListener('loadeddata', showVideo, { once: true });
        }
      }).catch(() => {
        // blocked — fallback to PNG
        t.video.style.display = 'none';
        t.img.style.display = 'block';
        t.shown = true;
      });
    } else {
      // synchronous play fallback
      t.video.requestVideoFrameCallback(() => showVideo());
    }
  } else {
    // Older browsers: wait for loadeddata then play (+ show)
    const onLoaded = () => {
      const p = t.video.play();
      if (p && typeof p.then === 'function') {
        p.then(showVideo).catch(() => {
          // Playback blocked — show png
          t.video.style.display = 'none';
          t.img.style.display = 'block';
          t.shown = true;
        });
      } else {
        showVideo();
      }
    };
    t.video.addEventListener('loadeddata', onLoaded, { once: true });
    // start loading & attempt to play
    try { t.video.load(); } catch(e){}
    try {
      const p = t.video.play();
      if (p && typeof p.then === 'function') p.catch(()=>{});
    } catch(e){}
  }

  // Fallback timeout: if nothing happens within ~1.2s, show PNG
  const fb = setTimeout(() => {
    if (!shown) {
      try { t.video.pause(); t.video.style.display = 'none'; } catch(e){}
      try { t.img.style.display = 'block'; } catch(e){}
      t.shown = true;
    }
  }, 1200);

  t.video.addEventListener('play', () => clearTimeout(fb), { once: true });
}


function clearAllTicks() {
  Array.from(grid.children).forEach(letter => {
    const t = letter._tick;
    if (!t) return;
    if (t.timeout) { clearTimeout(t.timeout); t.timeout = null; }
    // hide UI
    try { t.container.style.display = 'none'; } catch(e){}
    try { t.video.pause(); t.video.currentTime = 0; t.video.style.display = 'none'; } catch(e){}
    try { t.img.style.display = 'none'; } catch(e){}
    t.shown = false;
  });
}



    function resetProgress() {

                  // hide/stop ticks with the rest of the UI reset
      clearAllTicks();


      // stop any confetti if still running
      stopConfetti();
      state.playedLetters.clear();
      state.completed = false;
      updateProgress();
    }

    /*********************** Confetti (canvas) ***********************/
    function resizeConfettiCanvas() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      confettiCanvas.width = Math.floor(window.innerWidth * dpr);
      confettiCanvas.height = Math.floor(window.innerHeight * dpr);
      confettiCanvas.style.width = window.innerWidth + "px";
      confettiCanvas.style.height = window.innerHeight + "px";
      confettiCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    resizeConfettiCanvas();

    function createConfettiPieces(amount = 200) {
    const w = window.innerWidth;
    const h = window.innerHeight;
    const pieces = [];
    for (let i = 0; i < amount; i++) {
    pieces.push({
      x: Math.random() * w,
      y: Math.random() * -h * 0.8, // Start higher up
      vx: (Math.random() - 0.5) * 8, // More horizontal spread
      vy: Math.random() * 5 + 3, // Faster falling
      r: Math.random() * 10 + 8, // Bigger pieces (was 4-10, now 8-18)
      rot: Math.random() * 360,
      rotSpeed: (Math.random() - 0.5) * 12, // Faster rotation
      color: `hsl(${Math.floor(Math.random() * 360)},90%,60%)`, // More saturated
      shape: Math.floor(Math.random() * 3), // Different shapes
    });
  }
  return pieces;
}

    function drawConfettiFrame() {
  // Clear with transparency to allow fade effect
  confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
  
  // Set global alpha for fade effect
  confettiCtx.globalAlpha = state.confettiFadeOpacity;
  
  const pieces = state.confettiPieces;
  
  for (let i = 0; i < pieces.length; i++) {
    const p = pieces[i];
    confettiCtx.save();
    confettiCtx.translate(p.x, p.y);
    confettiCtx.rotate(p.rot * Math.PI / 180);
    confettiCtx.fillStyle = p.color;
    
    // Draw different shapes
    switch(p.shape) {
      case 0: // Rectangle (original)
        confettiCtx.fillRect(-p.r/2, -p.r/2, p.r, p.r*0.6);
        break;
      case 1: // Circle
        confettiCtx.beginPath();
        confettiCtx.arc(0, 0, p.r/2, 0, Math.PI * 2);
        confettiCtx.fill();
        break;
      case 2: // Triangle
        confettiCtx.beginPath();
        confettiCtx.moveTo(0, -p.r/2);
        confettiCtx.lineTo(p.r/2, p.r/2);
        confettiCtx.lineTo(-p.r/2, p.r/2);
        confettiCtx.closePath();
        confettiCtx.fill();
        break;
    }
    
    confettiCtx.restore();

    // Update position
    p.x += p.vx;
    p.y += p.vy;
    p.rot += p.rotSpeed;
    
    // Add slight gravity effect
    p.vy += 0.05;

    // Recycle when out of screen
    if (p.y > window.innerHeight + 20 || p.x < -20 || p.x > window.innerWidth + 20) {
      p.y = Math.random() * -window.innerHeight * 0.5;
      p.x = Math.random() * window.innerWidth;
      p.vx = (Math.random() - 0.5) * 8;
      p.vy = Math.random() * 4 + 2;
    }
  }
  
  // Reset global alpha
  confettiCtx.globalAlpha = 1;
  
  // Only continue animation if not in fade mode
  if (state.confettiFadeStartTime === null) {
    state.confettiAnimationId = requestAnimationFrame(drawConfettiFrame);
  }
}
    function startConfetti() {
  // accessibility: respect prefers-reduced-motion
  if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;
  stopConfettiImmediately();
  resizeConfettiCanvas();
  
  // Reset fade state
  state.confettiFadeOpacity = 1;
  state.confettiFadeStartTime = null;
  
  state.confettiPieces = createConfettiPieces(200);
  state.confettiAnimationId = requestAnimationFrame(drawConfettiFrame);
  // stop after CONFETTI_DURATION_MS automatically
  state.confettiTimeoutId = setTimeout(() => stopConfetti(), CONFETTI_DURATION_MS);
}
    function stopConfetti() {
  if (state.confettiAnimationId) {
    cancelAnimationFrame(state.confettiAnimationId);
    state.confettiAnimationId = null;
  }
  if (state.confettiTimeoutId) {
    clearTimeout(state.confettiTimeoutId);
    state.confettiTimeoutId = null;
  }
  
  // Start fade out animation instead of immediately clearing
  state.confettiFadeOpacity = 1;
  state.confettiFadeStartTime = Date.now();
  
  // Start fade animation
  function fadeOut() {
    const elapsed = Date.now() - state.confettiFadeStartTime;
    const fadeDuration = 2500; // 2.5 seconds
    
    if (elapsed < fadeDuration) {
      // Calculate current opacity
      state.confettiFadeOpacity = 1 - (elapsed / fadeDuration);
      
      // Continue animation
      state.confettiAnimationId = requestAnimationFrame(fadeOut);
    } else {
      // Fade complete, clear everything
      state.confettiFadeOpacity = 0;
      confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
      state.confettiPieces = [];
      state.confettiAnimationId = null;
      return;
    }
    
    // Draw with current opacity
    drawConfettiFrame();
  }
  
  // Start the fade animation
  state.confettiAnimationId = requestAnimationFrame(fadeOut);
}

    function stopConfettiImmediately() {
  if (state.confettiAnimationId) cancelAnimationFrame(state.confettiAnimationId);
  if (state.confettiTimeoutId) clearTimeout(state.confettiTimeoutId);
  state.confettiAnimationId = null;
  state.confettiTimeoutId = null;
  state.confettiPieces = [];
  state.confettiFadeOpacity = 1;
  state.confettiFadeStartTime = null;
  confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
}

    // ------------------------- Celebration (fixed) -------------------------
function celebrate() {
  // Cancel pending grayscale timeouts and remove previous class from all letters
  document.querySelectorAll('.letter').forEach(letter => {
    if (letter.grayscaleTimeout) {
      clearTimeout(letter.grayscaleTimeout);
      letter.grayscaleTimeout = null;
    }
    letter.classList.remove('previous');
  });

  try {
    celebrationSound.currentTime = 0;
    celebrationSound.play().catch(() => {});
  } catch (e) {}

  startConfetti();
}



    /*********************** Initialization ***********************/
    // initialize progress to 0
    updateProgress();

    // ensure overlay sizing after load
    window.addEventListener('load', () => {
      setTimeout(() => {
        const sizePx = parseFloat(getComputedStyle(mouth).width) || 180;
        updateOverlayForSize(sizePx);
      }, 100);
    });

    // make sure confetti canvas resizes on orientation change
    window.addEventListener('orientationchange', resizeConfettiCanvas);

    window.addEventListener('resize', updateAllTickPositions);
    window.addEventListener('scroll', updateAllTickPositions, { passive: true });
    window.addEventListener('orientationchange', updateAllTickPositions);


  </script>
</body>
</html>
