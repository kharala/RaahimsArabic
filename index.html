<!DOCTYPE html>
<html dir="rtl" lang="ar">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Raahim's Arabic</title>
  <style>
    :root { --gap: 10px; --max-width: 900px; --grid-cols: 5; --logo-size: 180px; }



    /* Background container */
.bg-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: -1; /* Behind all content */
  overflow: hidden;
}

/* Background image */
.bg-image {
  width: 100%;
  height: 100%;
  object-fit: cover; /* Cover the entire viewport */
  opacity: 0.3; /* 30% opacity */
  transition: transform 0.5s ease; /* Smooth scaling */
}

      .sultania-logo {
  position: absolute;
  left: 0;
  top: 10px;
  width: var(--logo-size);
  height: var(--logo-size);
  background: transparent;
  box-sizing: border-box;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 4000;
  pointer-events: auto;
  text-decoration: none;
}

/* Make sure the image fits the square and keeps its aspect ratio */
.sultania-logo img {
  width: 100%;
  height: 100%;
  object-fit: contain;
  display: block;
  border-radius: 4px; /* optional */
  background: transparent;
  -webkit-user-drag: none;
}

.page-header {
  display: flex;
  justify-content: center;
  align-items: center;
  width: 100%;
  max-width: var(--max-width);
  margin-bottom: 20px;
  position: relative;
}

.page-title {
  font-size: 3.0rem;
  font-family: "Playfair Display", Georgia, "Times New Roman", serif;
  font-weight: 600;
  color: #431fa1;
  margin: 0;
  text-align: center;
  flex-grow: 1;
}


                        /* ----------- Legend Styles ------------ */
.legend-container {
  width: 100%;
  max-width: var(--max-width);
  margin: 0 auto 20px auto;
  padding: 0 15px;
  box-sizing: border-box;
  position: relative;
  z-index: 100;
}

.legend {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: transparent;
  border-radius: 10px;
  padding: 12px 20px;
  gap: 15px;
  min-height: auto;
  height: auto;
}

.legend-item {
  display: flex;
  align-items: center;
  gap: 10px;
  flex: 1;
  justify-content: center;
  flex-direction: row-reverse;
}

.legend-color {
  width: 24px;
  height: 24px;
  border-radius: 5px;
  flex-shrink: 0;
  border: 1px solid rgba(0, 0, 0, 0.1);
}

.legend-text {
  font-size: 16px;
  font-weight: 600;
  color: #333;
  white-space: nowrap;
  line-height: 1;
}






    /* ----------- Settings Menu ------------ */
.settings-container {
  position: absolute;
  top: 20px;
  right: 20px;
  z-index: 5000;
}

.settings-button {
  background: transparent;
  color: #431fa1;
  border: none;
  width: 50px;
  height: 50px;
  font-size: 24px;
  cursor: pointer;
  transition: transform 0.3s ease;
}

.settings-button:hover {
  transform: rotate(45deg);
}

.settings-menu {
  position: absolute;
  top: 60px;
  right: 0;
  background: white;
  border-radius: 8px;
  padding: 15px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.15);
  width: 300px;
  display: none;
  z-index: 5001;
  font-size: 14px;
}

.settings-menu h3 {
  margin: 0 0 15px 0;
  color: #431fa1;
  text-align: center;
  border-bottom: 1px solid #eee;
  padding-bottom: 10px;
  font-size: 24px;
}

.settings-menu h4 {
  margin: 10px 0;
  color: #555;
  font-size: 20px;
  text-align: center;
}

.setting-item {
  margin: 12px 0;
  display: flex;
  align-items: center;
  justify-content: flex-start;
  direction: ltr;
}

.setting-item label {
  display: flex;
  align-items: center;
  cursor: pointer;
  justify-content: space-between; 
  width: 100%;
  direction: rtl; 
}

.setting-item input[type="checkbox"] {
  margin-left: 10px; 
  margin-right: 0;
  width: 18px;
  height: 18px;
  cursor: pointer;
}



.letter-toggle-grid {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: 8px;
  margin: 10px 0;
}

.letter-toggle {
  width: 100%;
  aspect-ratio: 1/1;
  border-radius: 50%;
  border: 2px solid #ddd;
  background: white;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: "Traditional Arabic", "Arabic Typesetting", serif;
  font-size: 16px;
  font-weight: bold;
  transition: all 0.2s ease;
}

.letter-toggle.active {
  border-color: #431fa1;
  background: #f0e8ff;
}

.letter-toggle.inactive {
  opacity: 0.4;
  filter: grayscale(100%);
}

/* Show menu when active */
.settings-container:hover .settings-menu,
.settings-menu.active {
  display: block;
}

                 /* ----------- Tablet view adjustments ------------ */
@media (max-width: 900px) {

  .grid {
    padding: 0 15px;
  }
  
  
  .page-header {
    flex-direction: column;
    align-items: center;
    padding: 0;
    margin-bottom: 15px;
  }
  
 
  .sultania-logo {
    position: absolute;
    left: 20px;
    top: 20px;
    width: 100px;
    height: 100px;
  }
  
 
  .page-title {
    font-size: 2.2rem;
    font-weight: 600;
    flex-grow: 1;
    text-align: center;
    margin: 0 auto;
    width: 100%;
    padding-top: 10px;
  }


  .settings-container {
    top: 15px;
    right: 15px;
  }
  
  .settings-button {
    width: 45px;
    height: 45px;
    font-size: 22px;
    background: transparent;
  }
  
  .settings-menu {
    width: 280px;
    right: -10px;
  }

  .legend-container {
    margin-bottom: 15px; 
    padding: 0 20px;
  }

  .legend {
    padding: 12px 16px;
    gap: 12px;
  }

  .legend-item {
      gap: 10px;
  }
  
  .legend-text {
    font-size: 14px;
    font-weight: 600;
  }
  
  .legend-color {
    width: 22px;
    height: 22px;
    border-radius: 5px;
  }
}



            /* ----------- Mobile view adjustments ------------ */

@media (max-width: 520px) {
  .settings-container {
    top: 10px;
    right: 10px;
  }
  
  .settings-button {
    width: 40px;
    height: 40px;
    font-size: 20px;
    background: transparent;
  }
  
  .settings-menu {
    width: 260px;
    right: -15px;
  }
  
  .letter-toggle-grid {
    grid-template-columns: repeat(5, 1fr);
  }

  .legend-container {
    margin-bottom: 10px;
    padding: 0 0px 0 60px;
  }

  .legend {
    flex-wrap: wrap;
    gap: 10px;
    padding: 6px 0;
    justify-content: center;
    flex-direction: row-reverse;
  }
  
  .legend-item {
    flex: 0 0 calc(50% - 5px);
    display: flex;
    align-items: center;
    gap: 8px;
    justify-content: flex-start;
    min-width: 0px;
  }
  
  .legend-text {
    font-size: 16px;
    flex-shrink: 1;
    min-width: 0;
  }

  .legend-color {
    width: 16px;
    height: 16px;
    border-radius: 4px;
    flex-shrink: 0;
    border: 1px solid rgba(0, 0, 0, 0.1);
  }
}


    body {
      font-family: "Playfair Display", Georgia, "Times New Roman", serif;
      background: transparent;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      box-sizing: border-box;
      position: relative;
    }

    

    .container {
      width: 100%;
      max-width: var(--max-width);
      display: grid;
      grid-template-rows: auto 1fr;
      gap: 18px;
      align-items: start;
      box-sizing: border-box;
      margin-top: 40px;
    }

    /* wrapper that moves with scroll (holds progress + mouth) */
    .mouth-wrapper {
      position: sticky;
      top: 70px; 
      z-index: 2000;
      width: 100%;
      max-width: var(--max-width);
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      pointer-events: none;
      background: transparent;
      padding: 0; 
    }

    /* Floating mouth circle with circular progress */
    .mouth-container {
      position: relative;
      width: 180px;
      height: 180px;
      margin: 0 auto 18px auto;
      pointer-events: auto;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .circular-progress {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      transform: rotate(-60deg); /* Start at top (clean) */
      shape-rendering: geometricPrecision;
    }

    .progress-ring {
      width: 100%;
      height: 100%;
      shape-rendering: geometricPrecision;
    }

    .progress-ring-circle {
      fill: none;
      stroke: transparent;
      stroke-width: 6;
    }

    .progress-ring-value {
      fill: none;
      stroke: #FFD700;
      stroke-width: 6;
      stroke-linecap: round;
      transition: stroke-dashoffset 0.45s cubic-bezier(.2,.9,.2,1);
    }

    .progress-text-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      pointer-events: none;
    }

    .progress-text {
      font-size: 14px;
      color: #333;
      margin: 0;
    }


    /* Curved text that lives in the arc gap */
.gap-text {
  font-size: 8px;
  font-weight: 700;
  fill: #333;
  pointer-events: none; /* don’t steal clicks */
}


    .mouth {
      transition: transform 0.18s ease;
      background: white;
      border-radius: 50%;
      border: 6px solid #FFFF00; /* Thicker border */
      display: flex;
      align-items: center;
      justify-content: center;
      aspect-ratio: 1/1;
      overflow: hidden;
      box-sizing: border-box;
      box-shadow: 0 4px 15px rgba(0,0,0,0.5);
      position: relative;
      width: 140px; /* default will be overridden by JS syncMouthSize */
      height: 140px;
      z-index: 2001;
    }
    .mouth.playing { transform: scale(1.03); }

    .mouth img, .mouth video {
      position: absolute;
      inset: 6%;
      width: 88%;
      height: 88%;
      border-radius: 12px;
      object-fit: contain;
      display: block;
      background: transparent;
    }
    .mouth video { z-index: 2; display: none; }
    .mouth img { z-index: 1; }
    .mouth.playing video { display: block; }

    /* Ring animation overlay */
    .mouth-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(-90deg);
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 3;
      overflow: visible;
      display: block;
    }
    .mouth-overlay svg {
      width: 100%;
      height: 100%;
      display: block;
      overflow: visible;
    }
    .overlay-ring {
      fill: none;
      stroke: #000;
      stroke-linecap: round;
      transition: stroke-dashoffset 0.5s ease-in-out;
    }


    @media (prefers-reduced-motion: reduce) {
      .overlay-ring {
        transition: none !important;
      }
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(var(--grid-cols), 1fr);
      grid-auto-rows: 1fr;
      gap: var(--gap);
      width: 100%;
      align-content: start;
      z-index: 1;
      margin-top: 6px;
      box-sizing: border-box;
    }

    .letter {
      cursor: pointer;
      transition: transform 0.32s ease, opacity 0.28s ease;
      position: relative;
      z-index: 10;
      box-sizing: border-box;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;

      border: 3px solid transparent;
      background: white;
      aspect-ratio: 1/1;
      overflow: hidden;

     
      background-image:
      linear-gradient(#ffffff, #ffffff),
      linear-gradient(to right,
      var(--left-border) 40%,       /* solid left */
      var(--right-border) 60%       /* solid right */
    );

      background-origin: padding-box, border-box;
      background-clip: padding-box, border-box;
      /* vendor prefix for older WebKit if needed */
      -webkit-background-clip: padding-box, border-box;

    }

    .letter img {
      width: 60%;
      height: 60%;
      object-fit: contain;
      user-select: none;
      pointer-events: none;
    }

    .letter.previous {
      filter: grayscale(100%);
      opacity: 0.6;
      /* pointer-events stays enabled so it remains clickable */
}


    .letter.active { transform: scale(1.95); z-index: 500; }
    .letter.shrink { transform: scale(0.88); opacity: 0.85; }
    .letter.inactive { filter: grayscale(100%); opacity: 0.6; pointer-events: none; }



         




        /* ----------- Mobile view adjustments ------------ */
@media (max-width: 520px) {
  :root { 
    --grid-cols: 3; 
    --logo-size: 80px;
  }

  body {
    padding: 15px; 
  }
  
  
  .page-header {
    flex-direction: column;
    align-items: center;
    padding: 0;
    margin-bottom: 10px;
  }
  
  
  .sultania-logo {
    position: absolute;
    left: 15px;
    top: 15px;
    width: var(--logo-size);
    height: var(--logo-size);
  }
  
  
  .page-title {
    font-weight: 600;
    flex-grow: 1;
    text-align: center;
    margin: 0 auto;
    width: 100%;
    font-size: 1.6rem;
    padding-top: 5px;

    font-size: 0;
    line-height: 1.3;
  }

  .page-title::before {
    content: "Arabic";
    display: block;
    text-align: center;
    font-size: 2.5rem;
    font-weight: 600;
    color: #431fa1;
  }
  
  .page-title::after {
    content: "Alphabet";
    display: block;
    text-align: center;
    font-size: 2.5rem;
    font-weight: 600;
    color: #431fa1;
  }
  

  .grid {
    padding: 0 10px; 
    gap: 12px; 
  }

  .letter {
    border-width: 3px;
  }

  .letter img {
    width: 55%; 
    height: 55%;
  }
  
  .mouth-wrapper { 
    top: 60px; /* Adjusted for mobile */
  }
  
  /* Adjust container margin for mobile */
  .container {
    margin-top: 30px;
  }
}



        /* ------ Extra small mobile devices ---------- */
@media (max-width: 380px) {
  .sultania-logo {
    width: 70px;
    height: 70px;
    left: 10px;
    top: 10px;
  }
  
  .page-title {
    font-size: 1.4rem;
    padding-top: 0;
  }

.legend {
    flex-direction: column-reverse;
    
  }

  .legend-item {
    flex: 0 0 auto; 
    width: 100%;
    justify-content: flex-start;
    gap: 8px;
  }

  .legend-text {
    font-size: 11px; /* Consistent size */
  }
  
  .legend-color {
    width: 16px; /* Consistent size */
    height: 16px;
  }
  

  
  :root {
    --logo-size: 70px;
  }
}

 

              /* -----------Confetti canvas----------- */
    canvas#confettiCanvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 3000;
    }



    /* -------------------- Tick badge layer -------------------- */
#tickLayer {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  background: transparent;
  height: 100%;
  pointer-events: none; /* clicks pass through */
  z-index: 1500;        /* above letters/mouth overlay but below confetti (confetti was 3000) */
}

/* Single tick badge (absolute page coords inside tickLayer) */
.tick-badge {
  position: absolute;
  background: transparent;
  transform: translate(-50%, -50%); /* center by left/top */
  pointer-events: none;
  display: none; /* toggled by JS */
  z-index: 2501;
  will-change: transform, opacity;
}

/* video & png use the badge size */
.tick-badge video,
.tick-badge img {
  display: block;
  width: 100%;
  height: 100%;
  object-fit: contain;
  pointer-events: none;
  user-select: none;
  -webkit-user-drag: none;
  background: transparent;
}


  </style>
</head>
<body>
  
    <div class="bg-container" id="bgContainer">
      <img src="BG.png" alt="Background" class="bg-image" id="bgImage">
    </div>

  <div class="page-header">
             
    <a href="https://www.youtube.com/user/SultaniaEducation" class="sultania-logo" aria-label="Sultania logo">
      <img src="sultaniaLogo.svg" alt="Sultania logo">
    </a>
    <h1 class="page-title">Arabic Alphabet</h1> 
  </div>




    <!--------------- Settings Button -------------------->


<div class="settings-container">
  <button class="settings-button" id="settingsButton" aria-label="الإعدادات">
    ⚙️
  </button>
  <div class="settings-menu" id="settingsMenu">
    <h3>Settings</h3>
    
    <div class="setting-group">
      <h4>Letters On/Off</h4>
      <div class="letter-toggle-grid" id="letterToggleGrid"></div>
    </div>
    
    <div class="setting-item">
      <label>
        <input type="checkbox" id="celebrationToggle" checked>
        Celebration
      </label>
    </div>
    
    <div class="setting-item">
      <label>
        <input type="checkbox" id="tickToggle" checked>
        Show tickmarks
      </label>
    </div>
    
    <div class="setting-item">
      <label>
        <input type="checkbox" id="grayscaleToggle" checked>
        Grayscale completed letters
      </label>
    </div>
  </div>
</div>





  <div class="container">
    <!-- Mouth wrapper (sticky) contains progress bar + mouth so they move together -->
    <div class="mouth-wrapper" id="mouthWrapper">

      <!-- Circular progress container -->
      <div class="mouth-container" id="mouthContainer">
        <!-- Circular progress SVG -->
        <div class="circular-progress" id="circularProgress">
          <svg class="progress-ring" viewBox="0 0 100 100">
  <!-- We draw on a 100x100 viewBox; circles use r=47 so 6px stroke stays inside -->

  <!-- 1) Define the small 60° gap arc as a path.
       NOTE: This path is defined for the *unrotated* ring (gap from ~1 o’clock to 3 o’clock).
       Your .circular-progress has rotate(-60deg), so this ends up centered at the top (11–1 o’clock). -->
  <defs>
    <!-- Center (50,50), radius 47.
         Start at θ=300° (upper-right): (x≈73.5, y≈9.3)
         End   at θ=  0° (right):       (x=97,   y=50) -->
    <path id="gapArcPath"
          d="M 73.5 9.3 A 47 47 0 0 1 97 50" />
  </defs>

  <!-- 2) The background circle and the yellow progress arc -->
  <circle class="progress-ring-circle" cx="50" cy="50" r="47" />
  <circle class="progress-ring-value" id="progressRingValue" cx="50" cy="50" r="47" />

  <!-- 3) Curved text that sits along the gap arc -->
  <text class="gap-text" direction="ltr">
    <!-- center the text in the middle of the gap arc -->
    <textPath id="gapTextPath"
              href="#gapArcPath"
              startOffset="50%"
              text-anchor="middle"
              dominant-baseline="central">0 / 30</textPath>
  </text>
</svg>


        </div>
        
        <!-- Progress text in the center -->
        <div class="progress-text-container">
          <div class="progress-text" id="progressText">0 / 30</div>
        </div>
        
        <!-- Floating mouth circle -->
        <div class="circle mouth" id="mouth" aria-label="شكل الفم">
          <img id="mouthDefault" src="mouths/default.png" alt="Default mouth">
          <video id="mouthVideo" playsinline muted></video>

          <!-- Ring animation overlay -->
          <div class="mouth-overlay" id="mouthOverlay" aria-hidden="true">
            <svg id="mouthOverlaySvg" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid meet" viewBox="0 0 100 100">
                <!-- initial centered values; updateOverlayForSize() will set exact values -->
              <circle id="overlayCircle" class="overlay-ring" cx="50" cy="50" r="44" stroke-width="6"></circle>
            </svg>
          </div>    

        </div>
      </div>
    </div>


                           <!-- Legend container -->

<div class="legend-container">
  <div class="legend" id="legend">
    <div class="legend-item">
      <div class="legend-color" style="background-color: #4633CC;"></div>
      <span class="legend-text">Lisp letters</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background-color: #DB0000;"></div>
      <span class="legend-text">Sibilant letters</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background-color: #FFFF12;"></div>
      <span class="legend-text">Fat letters</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background-color: #000000;"></div>
      <span class="legend-text">Thin letters</span>
      
    </div>
  </div>
</div>




    <!-- Letters grid -->
    <div class="grid" id="grid" role="list"></div>
  </div>

  <!-- Tick UI layer - badges live here (keeps them outside letter filters) -->
<div id="tickLayer" aria-hidden="true"></div>


  <!-- Confetti canvas -->
  <canvas id="confettiCanvas" aria-hidden="true"></canvas>

  <!-- Celebration sound (external URL so you don't need to add files locally) -->
  <audio id="celebrationSound" src="sounds/yay.mp3" preload="auto"></audio>

  <script>
    /*********************** Configuration ***********************/
    const LETTER_KEYS = [
      "alif","baa","taa","thaa","jeem",
      "haa","khaa","daal","zaal","raa",
      "zaa","seen","sheen","suad","duad",
      "tua","zua","ayn","ghayn","faa",
      "qaaf","kaaf","laam","meem","noon",
      "waw","hhaa","hamza","yaa","yaaa"
    ];

  const COLORS = [
     ["#000000","#000000"],
     ["#000000","#000000"],
     ["#000000","#000000"],
     ["#4633CC","#000000"],
     ["#000000","#000000"],
     ["#000000","#000000"],
     ["#FFFF12","#FFFF12"],
     ["#000000","#000000"],
     ["#4633CC","#000000"],
     ["#FFFF12","#FFFF12"],
     ["#DB0000","#000000"],
     ["#DB0000","#000000"],
     ["#000000","#000000"],
     ["#DB0000","#FFFF12"],
     ["#FFFF12","#FFFF12"],
     ["#FFFF12","#FFFF12"],
     ["#4633CC","#FFFF12"],
     ["#000000","#000000"],
     ["#FFFF12","#FFFF12"],
     ["#000000","#000000"],
     ["#FFFF12","#FFFF12"],
     ["#000000","#000000"],
     ["#000000","#000000"],
     ["#000000","#000000"],
     ["#000000","#000000"],
     ["#000000","#000000"],
     ["#000000","#000000"],
     ["#000000","#000000"],
     ["#000000","#000000"],
     ["#000000","#000000"],

];



    const MIN_RESET_MS = 300;
    const META_TIMEOUT_MS = 1500;
    const AUDIO_FALLBACK_MS = 4500;
    const OVERALL_SAFE_MS = 12000;
    const MOUTH_SCALE = 1.5;
    const AUTO_RESET_AFTER_COMPLETE_MS = 7000; // auto-reset delay after 30/30
    const CONFETTI_DURATION_MS = 7000; // how long confetti runs

    /*********************** DOM refs ***********************/
    const grid = document.getElementById('grid');
    const mouth = document.getElementById('mouth');
    const mouthVideo = document.getElementById('mouthVideo');
    const mouthDefault = document.getElementById('mouthDefault');
    const progressRingValue = document.getElementById('progressRingValue');
    const progressText = document.getElementById('progressText');
    const gapTextPath = document.getElementById('gapTextPath');

    const mouthOverlay = document.getElementById('mouthOverlay');
    const mouthOverlaySvg = document.getElementById('mouthOverlaySvg');
    const overlayCircle = document.getElementById('overlayCircle');

    const confettiCanvas = document.getElementById('confettiCanvas');
    const confettiCtx = confettiCanvas.getContext('2d');

    const celebrationSound = document.getElementById('celebrationSound');

    const tickLayer = document.getElementById('tickLayer') || (() => {
    const el = document.createElement('div');
      el.id = 'tickLayer';
      el.setAttribute('aria-hidden','true');
      el.style.position = 'absolute';
      el.style.top = '0';
      el.style.left = '0';
      el.style.width = '100%';
      el.style.height = '100%';
      el.style.pointerEvents = 'none';
      el.style.zIndex = '2500';
      document.body.appendChild(el);
    return el;
  })();


    /*********************** State ***********************/
    const state = {
      currentEl: null,
      currentKey: null,
      audio: null,
      audioTimer: null,
      metaTimeout: null,
      overallTimer: null,
      overlayCircumference: null,
      overlayActive: false,
      playedLetters: new Set(),
      completed: false,
      confettiPieces: [],
      confettiAnimationId: null,
      confettiTimeoutId: null,
      confettiFadeOpacity: 1,
      confettiFadeStartTime: null,
      settings: {
        celebrationEnabled: true,
        tickEnabled: true,
        grayscaleEnabled: true,
        disabledLetters: new Set()
      }
    };


    /*********************** Legend ***********************/

function updateLegendLayout() {
  const legend = document.getElementById('legend');
  const containerWidth = document.querySelector('.container').offsetWidth;
  
  // Adjust legend layout for very small screens
  if (containerWidth < 400) {
    document.querySelectorAll('.legend-item').forEach(item => {
      item.style.flex = '0 0 45%';
    });
  }
}

// Call on load and resize
window.addEventListener('load', updateLegendLayout);
window.addEventListener('resize', updateLegendLayout);




    /*********************** Build grid ***********************/
    
    function buildGrid() {
      grid.innerHTML = '';
      LETTER_KEYS.forEach((k, i) => {
    const color = COLORS[i % COLORS.length]; // map color by index
    const el = document.createElement('div');
    el.className = 'letter circle';
    el.setAttribute('data-key', k);
    el.setAttribute('role', 'listitem');
    el.innerHTML = `<img src="images/${k}.png" alt="${k}">`;

    // Determine left/right colours (support legacy single-string fallback)
    const pair = COLORS[i % COLORS.length];
    let left, right;
    if (Array.isArray(pair)) {
      [left, right] = pair;
    } else {
      left = right = pair || '#000';
    }

    // apply border split via CSS custom properties
    el.style.border = '4.5px solid transparent';
    el.style.setProperty('--left-border', left);
    el.style.setProperty('--right-border', right);

    // Create the tick-badge (kept outside the letter so letter filters don't affect it)
    const tickContainer = document.createElement('div');
    tickContainer.className = 'tick-badge';
    tickContainer.setAttribute('data-key', k);
    tickContainer.style.display = 'none'; // shown later by JS

    // Create tick video element
    const tickVideo = document.createElement('video');
        // Do NOT set .src immediately on older Safari fallback approach below.
        // We'll set src on browsers that support WebM.
    tickVideo.preload = 'auto';
    tickVideo.playsInline = true;
    tickVideo.muted = false;               // required for autoplay in many browsers
    tickVideo.style.display = 'none';     // hide until first frame ready
    tickVideo.style.background = 'transparent';
    tickVideo.setAttribute('aria-hidden', 'true');

                                        // Create tick image fallback
    const tickImg = document.createElement('img');
    tickImg.src = `mouths/tick.png`;
    tickImg.alt = 'tick';
    tickImg.style.display = 'none';
    tickImg.setAttribute('aria-hidden', 'true');

      // Only attach webm src if browser claims to support it (basic capability test)
    const canPlayWebm = document.createElement('video').canPlayType('video/webm; codecs="vp9,opus"') ||
                    document.createElement('video').canPlayType('video/webm; codecs="vp9"');
if (canPlayWebm) {
  tickVideo.src = `mouths/tick.webm`;
} else {
  // fallback immediately to png for browsers that can't play webm/vp9
  tickImg.style.display = 'block';
}


    // When the webm finishes, hide the video and show the png placeholder
    tickVideo.onended = () => {
      try { tickVideo.style.display = 'none'; } catch(e) {}
      try { tickImg.style.display = 'block'; } catch(e) {}
      el._tick && (el._tick.shown = true);
      // ensure the container remains visible if showing the image
      tickContainer.style.display = 'block';
    };

    tickContainer.appendChild(tickVideo);
    tickContainer.appendChild(tickImg);
    tickLayer.appendChild(tickContainer);

    // Attach tick metadata to the letter element so we can schedule/clear it later
    el._tick = {
      container: tickContainer,
      video: tickVideo,
      img: tickImg,
      timeout: null,
      shown: false
    };

    // Click handler (existing)
    el.addEventListener('click', () => onLetterClick(el, k));
    grid.appendChild(el);
  });

  // After building, position all tick badges
  requestAnimationFrame(() => updateAllTickPositions());
  
  // ADD THIS LINE to apply initial letter states based on settings
  updateLetterStates();
}



    buildGrid();










    /*********************** Size sync ***********************/
    function syncMouthSize() {
      const sample = grid.querySelector('.letter');
      if (!sample) return;
      const rect = sample.getBoundingClientRect();
      const size = Math.max(48, Math.round(rect.width * MOUTH_SCALE));
      mouth.style.width = size + 'px';
      mouth.style.height = size + 'px';
      
      // Update container size to match
      const containerSize = Math.round(size * 1.3);
      document.getElementById('mouthContainer').style.width = containerSize + 'px';
      document.getElementById('mouthContainer').style.height = containerSize + 'px';
      
      updateOverlayForSize(size);
    }
    window.addEventListener('load', () => { syncMouthSize(); setTimeout(syncMouthSize, 60); });
    window.addEventListener('resize', () => { syncMouthSize(); resizeConfettiCanvas(); });

    /*********************** Timers / cleanup ***********************/
    function clearAudioTimer() { if (state.audioTimer) { clearTimeout(state.audioTimer); state.audioTimer = null; } }
    function clearMetaTimeout() { if (state.metaTimeout) { clearTimeout(state.metaTimeout); state.metaTimeout = null; } }
    function clearOverallTimer() { if (state.overallTimer) { clearTimeout(state.overallTimer); state.overallTimer = null; } }

    function unloadVideo() {
      try { mouthVideo.pause(); } catch(e){}
      try { mouthVideo.onended = null; mouthVideo.onerror = null; } catch(e){}
      try { mouthVideo.removeAttribute('src'); mouthVideo.load(); } catch(e){}
      mouth.classList.remove('playing');
      mouthVideo.style.display = 'none';
      try { mouthDefault.style.display = 'block'; } catch(e){}
      clearMetaTimeout();
    }

    function unloadAudio() {
      if (state.audio) {
        try {
          state.audio.onended = null;
          state.audio.onerror = null;
        } catch(e){}
        try { state.audio.pause(); state.audio.currentTime = 0; } catch(e){}
      }
      state.audio = null;
      clearAudioTimer();
    }

    function cancelPlayback(resetUI = true) {
      unloadAudio();
      unloadVideo();
      clearOverallTimer();
      overlayReset();
      if (resetUI && state.currentEl) {
        state.currentEl.classList.remove('active');
        state.currentEl = null;
        state.currentKey = null;
      }
      Array.from(grid.children).forEach(child => child.classList.remove('shrink'));
    }

    function immediateResetByAudio() {
      unloadVideo();
      if (state.currentEl) state.currentEl.classList.remove('active');
      state.currentEl = null;
      state.currentKey = null;
      Array.from(grid.children).forEach(child => child.classList.remove('shrink'));
      unloadAudio();
      clearOverallTimer();
      overlayReset();
    }

    window.addEventListener('pagehide', () => { cancelPlayback(true); stopConfettiImmediately(); });
    window.addEventListener('beforeunload', () => { cancelPlayback(true); stopConfettiImmediately(); });

    // ------------------------- Click handler (fixed) -------------------------


      function onLetterClick(el, key) {
  // Check if this letter is disabled in settings
  if (state.settings.disabledLetters.has(key)) {
    return; // Don't proceed if letter is disabled
  }
  
  cancelPlayback(true);

  state.currentEl = el;
  state.currentKey = key;
  el.classList.add('active');
  Array.from(grid.children).forEach(child => {
    if (child !== el) child.classList.add('shrink');
  });

  // Clear any existing timeout on this letter
  if (el.grayscaleTimeout) {
    clearTimeout(el.grayscaleTimeout);
    el.grayscaleTimeout = null;
  }

  // clear any previously scheduled tick for this same letter
  if (el._tick && el._tick.timeout) {
    clearTimeout(el._tick.timeout);
    el._tick.timeout = null;
  }

  // Schedule grayscale effect after 4 seconds if enabled
  if (state.settings.grayscaleEnabled) {
    el.grayscaleTimeout = setTimeout(() => {
      // If timeout wasn't cleared, apply class and cleanup reference
      el.classList.add('previous');
      el.grayscaleTimeout = null;
    }, 4000);
  }

  startAudioAndScheduleReset(key, el);
  startVideoOverlay(key);

  // schedule the tick badge for this letter if enabled
  if (state.settings.tickEnabled) {
    scheduleTickForLetter(el);
  }

  clearOverallTimer();
  state.overallTimer = setTimeout(() => {
    immediateResetByAudio();
  }, OVERALL_SAFE_MS);

  // Progress tracking: add key only once (Set)
  if (!state.playedLetters.has(key)) {
    state.playedLetters.add(key);
    updateProgress();
  }
}



/*********************** Settings Functions ***********************/
    function initSettingsMenu() {
  const settingsButton = document.getElementById('settingsButton');
  const settingsMenu = document.getElementById('settingsMenu');
  
  // Toggle menu on button click OR touch
  function toggleMenu(e) {
    if (e) {
      e.stopPropagation();
      e.preventDefault(); // Prevent double-tap zoom on mobile
    }
    settingsMenu.classList.toggle('active');
  }
  
  // Add both click and touch event listeners
  settingsButton.addEventListener('click', toggleMenu);
  settingsButton.addEventListener('touchend', toggleMenu);
  
  // Close menu when clicking/touching outside
  function closeMenu(e) {
    if (!settingsMenu.contains(e.target) && e.target !== settingsButton) {
      settingsMenu.classList.remove('active');
    }
  }
  
  document.addEventListener('click', closeMenu);
  document.addEventListener('touchend', closeMenu);
  
  // Initialize letter toggles
  initLetterToggles();
  
  // Add event listeners for checkboxes
  document.getElementById('celebrationToggle').addEventListener('change', (e) => {
    state.settings.celebrationEnabled = e.target.checked;
    saveSettings();
  });
  
  document.getElementById('tickToggle').addEventListener('change', (e) => {
    state.settings.tickEnabled = e.target.checked;
    saveSettings();
  });
  
  document.getElementById('grayscaleToggle').addEventListener('change', (e) => {
    state.settings.grayscaleEnabled = e.target.checked;
    saveSettings();
    // Apply changes immediately
    updateLetterStates();
  });
  
  // Load saved settings
  loadSettings();
}

function initLetterToggles() {
  const toggleGrid = document.getElementById('letterToggleGrid');
  toggleGrid.innerHTML = '';
  
  LETTER_KEYS.forEach((key, index) => {
    const toggle = document.createElement('button');
    toggle.className = 'letter-toggle active';
    toggle.setAttribute('data-key', key);
    toggle.setAttribute('type', 'button');
    toggle.setAttribute('aria-label', `تفعيل/تعطيل ${key}`);
    
        // Use the first character of the key as a visual indicator

    //toggle.textContent = key.charAt(0).toUpperCase();
    //toggle.textContent = key; 


    const arabicLetters = {
  "alif": "ا", "baa": "ب", "taa": "ت", "thaa": "ث", "jeem": "ج",
  "haa": "ح", "khaa": "خ", "daal": "د", "zaal": "ذ", "raa": "ر",
  "zaa": "ز", "seen": "س", "sheen": "ش", "suad": "ص", "duad": "ض",
  "tua": "ط", "zua": "ظ", "ayn": "ع", "ghayn": "غ", "faa": "ف",
  "qaaf": "ق", "kaaf": "ك", "laam": "ل", "meem": "م", "noon": "ن",
  "waw": "و", "hhaa": "ه", "hamza": "ء", "yaa": "ى", "yaaa": "ے"
   };

toggle.textContent = arabicLetters[key] || key.charAt(0).toUpperCase();





    toggle.addEventListener('click', () => {
      toggle.classList.toggle('inactive');
      if (state.settings.disabledLetters.has(key)) {
        state.settings.disabledLetters.delete(key);
      } else {
        state.settings.disabledLetters.add(key);
      }
      saveSettings();
      updateLetterStates();
    });
    
    toggleGrid.appendChild(toggle);
  });
}

function updateLetterStates() {
  // Update grid letters based on settings
  Array.from(grid.children).forEach(letter => {
    const key = letter.getAttribute('data-key');
    
    if (state.settings.disabledLetters.has(key)) {
      letter.classList.add('inactive');
    } else {
      letter.classList.remove('inactive');
    }
  });
  
  // Update toggle buttons
  document.querySelectorAll('.letter-toggle').forEach(toggle => {
    const key = toggle.getAttribute('data-key');
    
    if (state.settings.disabledLetters.has(key)) {
      toggle.classList.add('inactive');
    } else {
      toggle.classList.remove('inactive');
    }
  });
}

function saveSettings() {
  const settingsToSave = {
    celebrationEnabled: state.settings.celebrationEnabled,
    tickEnabled: state.settings.tickEnabled,
    grayscaleEnabled: state.settings.grayscaleEnabled,
    disabledLetters: Array.from(state.settings.disabledLetters)
  };
  
  localStorage.setItem('arabicAlphabetSettings', JSON.stringify(settingsToSave));
}

function loadSettings() {
  const savedSettings = localStorage.getItem('arabicAlphabetSettings');
  
  if (savedSettings) {
    try {
      const settings = JSON.parse(savedSettings);
      
      state.settings.celebrationEnabled = settings.celebrationEnabled !== false;
      state.settings.tickEnabled = settings.tickEnabled !== false;
      state.settings.grayscaleEnabled = settings.grayscaleEnabled !== false;
      
      if (settings.disabledLetters && Array.isArray(settings.disabledLetters)) {
        state.settings.disabledLetters = new Set(settings.disabledLetters);
      }
      
      // Update UI to reflect loaded settings
      document.getElementById('celebrationToggle').checked = state.settings.celebrationEnabled;
      document.getElementById('tickToggle').checked = state.settings.tickEnabled;
      document.getElementById('grayscaleToggle').checked = state.settings.grayscaleEnabled;
      
      updateLetterStates();
    } catch (e) {
      console.error('Error loading settings:', e);
    }
  }
}



        /*********************** Celebration ***********************/

function celebrate() {
  if (!state.settings.celebrationEnabled) return;
  
  
  document.querySelectorAll('.letter').forEach(letter => {
    if (letter.grayscaleTimeout) {
      clearTimeout(letter.grayscaleTimeout);
      letter.grayscaleTimeout = null;
    }
    letter.classList.remove('previous');
  });

  try {
    celebrationSound.currentTime = 0;
    celebrationSound.play().catch(() => {});
  } catch (e) {}

  startConfetti();
}


    /*********************** Audio handling ***********************/
    function startAudioAndScheduleReset(key, letterEl) {
      unloadAudio();
      clearAudioTimer();
      clearMetaTimeout();

      let audio;
      try {
        audio = new Audio(`sounds/${key}.mp3`);
        audio.preload = 'metadata';
      } catch (e) {
        state.audio = null;
        state.audioTimer = setTimeout(() => immediateResetByAudio(), AUDIO_FALLBACK_MS);
        return;
      }

      const onMeta = () => {
        try { audio.removeEventListener('loadedmetadata', onMeta); } catch(e){}
        const dur = (isFinite(audio.duration) && audio.duration > 0) ? audio.duration : null;
        scheduleResetFromDuration(dur, audio, letterEl);
      };
      audio.addEventListener('loadedmetadata', onMeta, { once: true });

      state.metaTimeout = setTimeout(() => {
        try { audio.removeEventListener('loadedmetadata', onMeta); } catch(e){}
        const dur = (isFinite(audio.duration) && audio.duration > 0) ? audio.duration : null;
        scheduleResetFromDuration(dur, audio, letterEl);
      }, META_TIMEOUT_MS);

      const p = audio.play();
      if (p && typeof p.then === 'function') {
        p.then(() => { overlayStart(); }).catch(() => { scheduleResetFromDuration(null, audio, letterEl); });
      }
      audio.onended = () => { immediateResetByAudio(); };
      audio.onerror = () => { immediateResetByAudio(); };

      state.audio = audio;
    }

    function scheduleResetFromDuration(durationSec, audioObj, letterEl) {
      clearMetaTimeout();
      clearAudioTimer();

      let ms;
      if (durationSec && isFinite(durationSec) && durationSec > 0) {
        ms = Math.max(MIN_RESET_MS, Math.ceil(durationSec * 1000) + 150);
      } else {
        ms = AUDIO_FALLBACK_MS;
      }

      state.audioTimer = setTimeout(() => {
        try { if (state.audio) { state.audio.pause(); state.audio.currentTime = 0; } } catch(e){}
        immediateResetByAudio();
      }, ms);
    }

    function startVideoOverlay(key) {
      try {
        mouth.classList.add('playing');
        mouthVideo.style.display = 'block';
        mouthVideo.src = `mouths/${key}.webm`;
        mouthVideo.load();

        const v = mouthVideo.play();
        if (v && typeof v.then === 'function') { v.catch(() => {}); }

        mouthVideo.onended = () => { unloadVideo(); };
        mouthVideo.onerror = () => { unloadVideo(); };
      } catch (e) { unloadVideo(); }
    }

    /*********************** Overlay animation functions ***********************/
    function updateOverlayForSize(sizePx) {
      const borderPx = 6; // match border
      mouthOverlaySvg.setAttribute('viewBox', `0 0 ${sizePx} ${sizePx}`);
      mouthOverlaySvg.setAttribute('width', sizePx);
      mouthOverlaySvg.setAttribute('height', sizePx);
      const cx = sizePx / 2;
      const cy = sizePx / 2;
      const r = Math.max(2, (sizePx / 2) - (borderPx * 0.5));
      overlayCircle.setAttribute('cx', cx.toString());
      overlayCircle.setAttribute('cy', cy.toString());
      overlayCircle.setAttribute('r', r.toString());
      overlayCircle.setAttribute('stroke-width', borderPx.toString());
      const circumference = 2 * Math.PI * r;
      overlayCircle.style.strokeDasharray = `${circumference}`;
      overlayCircle.style.strokeDashoffset = `${circumference}`;
      state.overlayCircumference = circumference;
    }

    function overlayStart() {
      if (!state.overlayCircumference) {
        const size = parseFloat(getComputedStyle(mouth).width) || 100;
        updateOverlayForSize(size);
      }
      if (state.overlayActive) return;

      const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      const c = state.overlayCircumference || 0;

      if (prefersReduced) {
        overlayCircle.style.strokeDashoffset = '0';
        state.overlayActive = true;
        return;
      }

      overlayCircle.style.strokeDashoffset = `${c}`;
      void overlayCircle.getBoundingClientRect();
      requestAnimationFrame(() => {
        overlayCircle.style.strokeDashoffset = '0';
        state.overlayActive = true;
      });
    }

    function overlayReset() {
      if (!state.overlayActive && !state.overlayCircumference) return;

      const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      const c = state.overlayCircumference || 0;

      if (prefersReduced) {
        overlayCircle.style.strokeDashoffset = `${c}`;
        state.overlayActive = false;
        return;
      }

      overlayCircle.style.strokeDashoffset = `${c}`;
      state.overlayActive = false;
    }

    /*********************** Circular Progress & Completion ***********************/
    function updateProgress() {
      const count = state.playedLetters.size;
      const total = LETTER_KEYS.length;
      const percent = (count / total) * 100;
      
     // Update circular progress
      // get radius from the SVG element so JS math always matches the SVG
      const radius = parseFloat(progressRingValue.getAttribute('r')) || 47;
      const circumference = 2 * Math.PI * radius;
      // Cover 80% of the circle (from 1 o'clock to 11 o'clock)
      const arcLength = circumference * (5/6);
      const offset = arcLength - (percent / 100) * arcLength;
      
      progressRingValue.style.strokeDasharray = `${arcLength} ${circumference}`;
      progressRingValue.style.strokeDashoffset = offset;
      
      // Update text
      progressText.textContent = `${count} / ${total}`;
      if (gapTextPath) {
        gapTextPath.textContent = `${count} / ${total}`;
      }


      // If completed and not yet handled, trigger celebration
      if (count >= total && !state.completed) {
        state.completed = true;
        setTimeout(() => {
          celebrate();
        }, 3700); // 2 second delay
        // auto reset after configured ms
        setTimeout(() => {
          resetProgress();
        }, AUTO_RESET_AFTER_COMPLETE_MS);
      }
    }


    // -------------------- Tick badge helpers --------------------

function positionTickForLetter(letterEl) {
  if (!letterEl || !letterEl._tick || !letterEl._tick.container) return;
  const t = letterEl._tick;
  const rect = letterEl.getBoundingClientRect();
  const w = rect.width;
  const h = rect.height;
  const cx = rect.left + w / 2 + window.scrollX;
  const cy = rect.top + h / 2 + window.scrollY;

  // circle radius (we assume letter is circular).
  const R = Math.min(w, h) / 2;

  // Angle system: degrees measured clockwise from top (0° = 12 o'clock).
  const angleDeg = 133; // per your spec (between 4 and 5 o'clock)
  const rad = angleDeg * Math.PI / 180;

  // Place the center of the tick on the circumference (makes it half-on/half-off visually).
  const d = R;

  // Convert to page coords (screen Y positive down). Mapping derived for clockwise-from-top:
  const x = cx + Math.sin(rad) * d;
  const y = cy - Math.cos(rad) * d;

  // pick badge size relative to letter size
  const tickSize = Math.max(18, Math.round(w * 0.36)); // tweak multiplier if you want bigger/smaller

  t.container.style.left = x + 'px';
  t.container.style.top = y + 'px';
  t.container.style.width = tickSize + 'px';
  t.container.style.height = tickSize + 'px';
}

function updateAllTickPositions() {
  // iterate letters
  Array.from(grid.children).forEach(letter => {
    if (letter._tick) positionTickForLetter(letter);
  });
}

// schedule tick webm to play 4s after clicking the letter
function scheduleTickForLetter(letterEl) {
  if (!letterEl || !letterEl._tick) return;
  const t = letterEl._tick;
  if (t.shown) return; // already shown/persisted

  // clear existing scheduled tick for this letter
  if (t.timeout) {
    clearTimeout(t.timeout);
    t.timeout = null;
  }

  // schedule at same 4 seconds as your grayscale (explicitly set)
  t.timeout = setTimeout(() => {
    playTickForLetter(letterEl);
    t.timeout = null;
  }, 4000);
}

    function playTickForLetter(letterEl) {
  if (!letterEl || !letterEl._tick) return;
  const t = letterEl._tick;

  // If placeholder already shown, show it and return
  if (t.shown) {
    t.container.style.display = 'block';
    t.img.style.display = 'block';
    return;
  }

  // Show container but keep video hidden until we have a frame
  t.container.style.display = 'block';
  t.img.style.display = 'none';
  t.video.style.display = 'none';

  // Safety flag & fallback
  let shown = false;
  function showVideo() {
    if (shown) return;
    shown = true;
    try { t.video.style.display = 'block'; } catch(e){}
    try { t.img.style.display = 'none'; } catch(e){}
  }

  // If browser supports requestVideoFrameCallback, wait for first painted frame
  if (t.video.requestVideoFrameCallback) {
    const p = t.video.play();
    if (p && typeof p.then === 'function') {
      p.then(() => {
        try {
          t.video.requestVideoFrameCallback(() => {
            showVideo();
          });
        } catch (e) {
          // fallback to loadeddata
          t.video.addEventListener('loadeddata', showVideo, { once: true });
        }
      }).catch(() => {
        // blocked — fallback to PNG
        t.video.style.display = 'none';
        t.img.style.display = 'block';
        t.shown = true;
      });
    } else {
      // synchronous play fallback
      t.video.requestVideoFrameCallback(() => showVideo());
    }
  } else {
    // Older browsers: wait for loadeddata then play (+ show)
    const onLoaded = () => {
      const p = t.video.play();
      if (p && typeof p.then === 'function') {
        p.then(showVideo).catch(() => {
          // Playback blocked — show png
          t.video.style.display = 'none';
          t.img.style.display = 'block';
          t.shown = true;
        });
      } else {
        showVideo();
      }
    };
    t.video.addEventListener('loadeddata', onLoaded, { once: true });
    // start loading & attempt to play
    try { t.video.load(); } catch(e){}
    try {
      const p = t.video.play();
      if (p && typeof p.then === 'function') p.catch(()=>{});
    } catch(e){}
  }

  // Fallback timeout: if nothing happens within ~1.2s, show PNG
  const fb = setTimeout(() => {
    if (!shown) {
      try { t.video.pause(); t.video.style.display = 'none'; } catch(e){}
      try { t.img.style.display = 'block'; } catch(e){}
      t.shown = true;
    }
  }, 1200);

  t.video.addEventListener('play', () => clearTimeout(fb), { once: true });
}


function clearAllTicks() {
  Array.from(grid.children).forEach(letter => {
    const t = letter._tick;
    if (!t) return;
    if (t.timeout) { clearTimeout(t.timeout); t.timeout = null; }
    // hide UI
    try { t.container.style.display = 'none'; } catch(e){}
    try { t.video.pause(); t.video.currentTime = 0; t.video.style.display = 'none'; } catch(e){}
    try { t.img.style.display = 'none'; } catch(e){}
    t.shown = false;
  });
}



    function resetProgress() {

                  // hide/stop ticks with the rest of the UI reset
      clearAllTicks();


      // stop any confetti if still running
      stopConfetti();
      state.playedLetters.clear();
      state.completed = false;
      updateProgress();
    }

    /*********************** Confetti (canvas) ***********************/
    function resizeConfettiCanvas() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      confettiCanvas.width = Math.floor(window.innerWidth * dpr);
      confettiCanvas.height = Math.floor(window.innerHeight * dpr);
      confettiCanvas.style.width = window.innerWidth + "px";
      confettiCanvas.style.height = window.innerHeight + "px";
      confettiCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    resizeConfettiCanvas();

    function createConfettiPieces(amount = 200) {
    const w = window.innerWidth;
    const h = window.innerHeight;
    const pieces = [];
    for (let i = 0; i < amount; i++) {
    pieces.push({
      x: Math.random() * w,
      y: Math.random() * -h * 0.8, // Start higher up
      vx: (Math.random() - 0.5) * 8, // More horizontal spread
      vy: Math.random() * 5 + 3, // Faster falling
      r: Math.random() * 10 + 8, // Bigger pieces (was 4-10, now 8-18)
      rot: Math.random() * 360,
      rotSpeed: (Math.random() - 0.5) * 12, // Faster rotation
      color: `hsl(${Math.floor(Math.random() * 360)},90%,60%)`, // More saturated
      shape: Math.floor(Math.random() * 3), // Different shapes
    });
  }
  return pieces;
}

    function drawConfettiFrame() {
  // Clear with transparency to allow fade effect
  confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
  
  // Set global alpha for fade effect
  confettiCtx.globalAlpha = state.confettiFadeOpacity;
  
  const pieces = state.confettiPieces;
  
  for (let i = 0; i < pieces.length; i++) {
    const p = pieces[i];
    confettiCtx.save();
    confettiCtx.translate(p.x, p.y);
    confettiCtx.rotate(p.rot * Math.PI / 180);
    confettiCtx.fillStyle = p.color;
    
    // Draw different shapes
    switch(p.shape) {
      case 0: // Rectangle (original)
        confettiCtx.fillRect(-p.r/2, -p.r/2, p.r, p.r*0.6);
        break;
      case 1: // Circle
        confettiCtx.beginPath();
        confettiCtx.arc(0, 0, p.r/2, 0, Math.PI * 2);
        confettiCtx.fill();
        break;
      case 2: // Triangle
        confettiCtx.beginPath();
        confettiCtx.moveTo(0, -p.r/2);
        confettiCtx.lineTo(p.r/2, p.r/2);
        confettiCtx.lineTo(-p.r/2, p.r/2);
        confettiCtx.closePath();
        confettiCtx.fill();
        break;
    }
    
    confettiCtx.restore();

    // Update position
    p.x += p.vx;
    p.y += p.vy;
    p.rot += p.rotSpeed;
    
    // Add slight gravity effect
    p.vy += 0.05;

    // Recycle when out of screen
    if (p.y > window.innerHeight + 20 || p.x < -20 || p.x > window.innerWidth + 20) {
      p.y = Math.random() * -window.innerHeight * 0.5;
      p.x = Math.random() * window.innerWidth;
      p.vx = (Math.random() - 0.5) * 8;
      p.vy = Math.random() * 4 + 2;
    }
  }
  
  // Reset global alpha
  confettiCtx.globalAlpha = 1;
  
  // Only continue animation if not in fade mode
  if (state.confettiFadeStartTime === null) {
    state.confettiAnimationId = requestAnimationFrame(drawConfettiFrame);
  }
}
    
    function startConfetti() {
  // accessibility: respect prefers-reduced-motion AND settings
  if (window.matchMedia('(prefers-reduced-motion: reduce)').matches || 
      !state.settings.celebrationEnabled) return;
  stopConfettiImmediately();
  resizeConfettiCanvas();
  
  // Reset fade state
  state.confettiFadeOpacity = 1;
  state.confettiFadeStartTime = null;
  
  state.confettiPieces = createConfettiPieces(200);
  state.confettiAnimationId = requestAnimationFrame(drawConfettiFrame);
  // stop after CONFETTI_DURATION_MS automatically
  state.confettiTimeoutId = setTimeout(() => stopConfetti(), CONFETTI_DURATION_MS);
}


    function stopConfetti() {
  if (state.confettiAnimationId) {
    cancelAnimationFrame(state.confettiAnimationId);
    state.confettiAnimationId = null;
  }
  if (state.confettiTimeoutId) {
    clearTimeout(state.confettiTimeoutId);
    state.confettiTimeoutId = null;
  }
  
  // Start fade out animation instead of immediately clearing
  state.confettiFadeOpacity = 1;
  state.confettiFadeStartTime = Date.now();
  
  // Start fade animation
  function fadeOut() {
    const elapsed = Date.now() - state.confettiFadeStartTime;
    const fadeDuration = 2500; // 2.5 seconds
    
    if (elapsed < fadeDuration) {
      // Calculate current opacity
      state.confettiFadeOpacity = 1 - (elapsed / fadeDuration);
      
      // Continue animation
      state.confettiAnimationId = requestAnimationFrame(fadeOut);
    } else {
      // Fade complete, clear everything
      state.confettiFadeOpacity = 0;
      confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
      state.confettiPieces = [];
      state.confettiAnimationId = null;
      return;
    }
    
    // Draw with current opacity
    drawConfettiFrame();
  }
  
  // Start the fade animation
  state.confettiAnimationId = requestAnimationFrame(fadeOut);
}

    function stopConfettiImmediately() {
  if (state.confettiAnimationId) cancelAnimationFrame(state.confettiAnimationId);
  if (state.confettiTimeoutId) clearTimeout(state.confettiTimeoutId);
  state.confettiAnimationId = null;
  state.confettiTimeoutId = null;
  state.confettiPieces = [];
  state.confettiFadeOpacity = 1;
  state.confettiFadeStartTime = null;
  confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
}




    /*********************** Initialization ***********************/
    // initialize progress to 0
    updateProgress();
  
    initSettingsMenu();

   

    // ensure overlay sizing after load
    window.addEventListener('load', () => {
      setTimeout(() => {
        const sizePx = parseFloat(getComputedStyle(mouth).width) || 180;
        updateOverlayForSize(sizePx);
      }, 100);
    });

    // make sure confetti canvas resizes on orientation change
    window.addEventListener('orientationchange', resizeConfettiCanvas);

    window.addEventListener('resize', updateAllTickPositions);
    window.addEventListener('scroll', updateAllTickPositions, { passive: true });
    window.addEventListener('orientationchange', updateAllTickPositions);


    /*********************** Background Image Controls ***********************/
const bgContainer = document.getElementById('bgContainer');
const bgImage = document.getElementById('bgImage');

// Initial background settings
let bgSettings = {
  scale: 1,
  positionX: 0,
  positionY: 0,
  opacity: 0.3
};

// Function to update background properties
function updateBackground() {
  bgImage.style.transform = `translate(${bgSettings.positionX}px, ${bgSettings.positionY}px) scale(${bgSettings.scale})`;
  bgImage.style.opacity = bgSettings.opacity;
}

// Function to adjust background (call this after visual inspection)
function adjustBackground(settings = {}) {
  if (settings.scale !== undefined) bgSettings.scale = settings.scale;
  if (settings.positionX !== undefined) bgSettings.positionX = settings.positionX;
  if (settings.positionY !== undefined) bgSettings.positionY = settings.positionY;
  if (settings.opacity !== undefined) bgSettings.opacity = settings.opacity;
  
  updateBackground();
}



// Make the adjustment function available globally
window.adjustBackground = adjustBackground;

// Initialize background
updateBackground();



  </script>
</body>
</html>
